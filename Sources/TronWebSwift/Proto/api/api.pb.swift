// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Protocol_Return {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Bool = false

  public var code: Protocol_Return.response_code = .success

  public var message: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum response_code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case success // = 0

    /// error in signature
    case sigerror // = 1
    case contractValidateError // = 2
    case contractExeError // = 3
    case bandwithError // = 4
    case dupTransactionError // = 5
    case taposError // = 6
    case tooBigTransactionError // = 7
    case transactionExpirationError // = 8
    case serverBusy // = 9
    case noConnection // = 10
    case notEnoughEffectiveConnection // = 11
    case otherError // = 20
    case UNRECOGNIZED(Int)

    public init() {
      self = .success
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .success
      case 1: self = .sigerror
      case 2: self = .contractValidateError
      case 3: self = .contractExeError
      case 4: self = .bandwithError
      case 5: self = .dupTransactionError
      case 6: self = .taposError
      case 7: self = .tooBigTransactionError
      case 8: self = .transactionExpirationError
      case 9: self = .serverBusy
      case 10: self = .noConnection
      case 11: self = .notEnoughEffectiveConnection
      case 20: self = .otherError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .success: return 0
      case .sigerror: return 1
      case .contractValidateError: return 2
      case .contractExeError: return 3
      case .bandwithError: return 4
      case .dupTransactionError: return 5
      case .taposError: return 6
      case .tooBigTransactionError: return 7
      case .transactionExpirationError: return 8
      case .serverBusy: return 9
      case .noConnection: return 10
      case .notEnoughEffectiveConnection: return 11
      case .otherError: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Return.response_code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Return.response_code] = [
    .success,
    .sigerror,
    .contractValidateError,
    .contractExeError,
    .bandwithError,
    .dupTransactionError,
    .taposError,
    .tooBigTransactionError,
    .transactionExpirationError,
    .serverBusy,
    .noConnection,
    .notEnoughEffectiveConnection,
    .otherError,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_BlockReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockNum: Int64 = 0

  public var blockHash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_WitnessList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var witnesses: [Protocol_Witness] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ProposalList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var proposals: [Protocol_Proposal] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ExchangeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchanges: [Protocol_Exchange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_AssetIssueList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assetIssue: [Protocol_AssetIssueContract] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_BlockList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var block: [Protocol_Block] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TransactionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transaction: [Protocol_Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TransactionIdList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var txID: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DelegatedResourceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fromAddress: Data = Data()

  public var toAddress: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DelegatedResourceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var delegatedResource: [Protocol_DelegatedResource] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_GetAvailableUnfreezeCountRequestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ownerAddress: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_GetAvailableUnfreezeCountResponseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_CanDelegatedMaxSizeRequestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Int32 = 0

  public var ownerAddress: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_CanDelegatedMaxSizeResponseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maxSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_CanWithdrawUnfreezeAmountRequestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ownerAddress: Data = Data()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_CanWithdrawUnfreezeAmountResponseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Gossip node list
public struct Protocol_NodeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodes: [Protocol_Node] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Gossip node
public struct Protocol_Node {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Protocol_Address {
    get {return _address ?? Protocol_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Protocol_Address? = nil
}

/// Gossip node address
public struct Protocol_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: Data = Data()

  public var port: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_EmptyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_NumberMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var num: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_BytesMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TimeMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beginInMilliseconds: Int64 = 0

  public var endInMilliseconds: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_BlockReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idOrNum: String = String()

  public var detail: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_BlockLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startNum: Int64 = 0

  public var endNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TransactionLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionID: Data = Data()

  public var limitNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_AccountPaginated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Protocol_Account {
    get {return _account ?? Protocol_Account()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  public var offset: Int64 = 0

  public var limit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Protocol_Account? = nil
}

public struct Protocol_TimePaginatedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeMessage: Protocol_TimeMessage {
    get {return _timeMessage ?? Protocol_TimeMessage()}
    set {_timeMessage = newValue}
  }
  /// Returns true if `timeMessage` has been explicitly set.
  public var hasTimeMessage: Bool {return self._timeMessage != nil}
  /// Clears the value of `timeMessage`. Subsequent reads from it will return its default value.
  public mutating func clearTimeMessage() {self._timeMessage = nil}

  public var offset: Int64 = 0

  public var limit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeMessage: Protocol_TimeMessage? = nil
}

///deprecated
public struct Protocol_AccountNetMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var freeNetUsed: Int64 = 0

  public var freeNetLimit: Int64 = 0

  public var netUsed: Int64 = 0

  public var netLimit: Int64 = 0

  public var assetNetUsed: Dictionary<String,Int64> = [:]

  public var assetNetLimit: Dictionary<String,Int64> = [:]

  public var totalNetLimit: Int64 = 0

  public var totalNetWeight: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_AccountResourceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var freeNetUsed: Int64 {
    get {return _storage._freeNetUsed}
    set {_uniqueStorage()._freeNetUsed = newValue}
  }

  public var freeNetLimit: Int64 {
    get {return _storage._freeNetLimit}
    set {_uniqueStorage()._freeNetLimit = newValue}
  }

  public var netUsed: Int64 {
    get {return _storage._netUsed}
    set {_uniqueStorage()._netUsed = newValue}
  }

  public var netLimit: Int64 {
    get {return _storage._netLimit}
    set {_uniqueStorage()._netLimit = newValue}
  }

  public var assetNetUsed: Dictionary<String,Int64> {
    get {return _storage._assetNetUsed}
    set {_uniqueStorage()._assetNetUsed = newValue}
  }

  public var assetNetLimit: Dictionary<String,Int64> {
    get {return _storage._assetNetLimit}
    set {_uniqueStorage()._assetNetLimit = newValue}
  }

  public var totalNetLimit: Int64 {
    get {return _storage._totalNetLimit}
    set {_uniqueStorage()._totalNetLimit = newValue}
  }

  public var totalNetWeight: Int64 {
    get {return _storage._totalNetWeight}
    set {_uniqueStorage()._totalNetWeight = newValue}
  }

  public var totalTronPowerWeight: Int64 {
    get {return _storage._totalTronPowerWeight}
    set {_uniqueStorage()._totalTronPowerWeight = newValue}
  }

  public var tronPowerUsed: Int64 {
    get {return _storage._tronPowerUsed}
    set {_uniqueStorage()._tronPowerUsed = newValue}
  }

  public var tronPowerLimit: Int64 {
    get {return _storage._tronPowerLimit}
    set {_uniqueStorage()._tronPowerLimit = newValue}
  }

  public var energyUsed: Int64 {
    get {return _storage._energyUsed}
    set {_uniqueStorage()._energyUsed = newValue}
  }

  public var energyLimit: Int64 {
    get {return _storage._energyLimit}
    set {_uniqueStorage()._energyLimit = newValue}
  }

  public var totalEnergyLimit: Int64 {
    get {return _storage._totalEnergyLimit}
    set {_uniqueStorage()._totalEnergyLimit = newValue}
  }

  public var totalEnergyWeight: Int64 {
    get {return _storage._totalEnergyWeight}
    set {_uniqueStorage()._totalEnergyWeight = newValue}
  }

  public var storageUsed: Int64 {
    get {return _storage._storageUsed}
    set {_uniqueStorage()._storageUsed = newValue}
  }

  public var storageLimit: Int64 {
    get {return _storage._storageLimit}
    set {_uniqueStorage()._storageLimit = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protocol_PaginatedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var offset: Int64 = 0

  public var limit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_EasyTransferMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var passPhrase: Data = Data()

  public var toAddress: Data = Data()

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_EasyTransferAssetMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var passPhrase: Data = Data()

  public var toAddress: Data = Data()

  public var assetID: String = String()

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_EasyTransferByPrivateMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var privateKey: Data = Data()

  public var toAddress: Data = Data()

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_EasyTransferAssetByPrivateMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var privateKey: Data = Data()

  public var toAddress: Data = Data()

  public var assetID: String = String()

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_EasyTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transaction: Protocol_Transaction {
    get {return _transaction ?? Protocol_Transaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  public var result: Protocol_Return {
    get {return _result ?? Protocol_Return()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  ///transaction id =  sha256(transaction.rowdata)
  public var txid: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transaction: Protocol_Transaction? = nil
  fileprivate var _result: Protocol_Return? = nil
}

public struct Protocol_AddressPrKeyPairMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var privateKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TransactionExtention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transaction: Protocol_Transaction {
    get {return _storage._transaction ?? Protocol_Transaction()}
    set {_uniqueStorage()._transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return _storage._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {_uniqueStorage()._transaction = nil}

  ///transaction id =  sha256(transaction.rowdata)
  public var txid: Data {
    get {return _storage._txid}
    set {_uniqueStorage()._txid = newValue}
  }

  public var constantResult: [Data] {
    get {return _storage._constantResult}
    set {_uniqueStorage()._constantResult = newValue}
  }

  public var result: Protocol_Return {
    get {return _storage._result ?? Protocol_Return()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {_uniqueStorage()._result = nil}

  public var energyUsed: Int64 {
    get {return _storage._energyUsed}
    set {_uniqueStorage()._energyUsed = newValue}
  }

  public var logs: [Protocol_TransactionInfo.Log] {
    get {return _storage._logs}
    set {_uniqueStorage()._logs = newValue}
  }

  public var internalTransactions: [Protocol_InternalTransaction] {
    get {return _storage._internalTransactions}
    set {_uniqueStorage()._internalTransactions = newValue}
  }

  public var energyPenalty: Int64 {
    get {return _storage._energyPenalty}
    set {_uniqueStorage()._energyPenalty = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protocol_EstimateEnergyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Protocol_Return {
    get {return _result ?? Protocol_Return()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var energyRequired: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Protocol_Return? = nil
}

public struct Protocol_BlockExtention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactions: [Protocol_TransactionExtention] = []

  public var blockHeader: Protocol_BlockHeader {
    get {return _blockHeader ?? Protocol_BlockHeader()}
    set {_blockHeader = newValue}
  }
  /// Returns true if `blockHeader` has been explicitly set.
  public var hasBlockHeader: Bool {return self._blockHeader != nil}
  /// Clears the value of `blockHeader`. Subsequent reads from it will return its default value.
  public mutating func clearBlockHeader() {self._blockHeader = nil}

  public var blockid: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _blockHeader: Protocol_BlockHeader? = nil
}

public struct Protocol_BlockListExtention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var block: [Protocol_BlockExtention] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TransactionListExtention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transaction: [Protocol_TransactionExtention] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_BlockIncrementalMerkleTree {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var number: Int64 = 0

  public var merkleTree: Protocol_IncrementalMerkleTree {
    get {return _merkleTree ?? Protocol_IncrementalMerkleTree()}
    set {_merkleTree = newValue}
  }
  /// Returns true if `merkleTree` has been explicitly set.
  public var hasMerkleTree: Bool {return self._merkleTree != nil}
  /// Clears the value of `merkleTree`. Subsequent reads from it will return its default value.
  public mutating func clearMerkleTree() {self._merkleTree = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _merkleTree: Protocol_IncrementalMerkleTree? = nil
}

public struct Protocol_TransactionSignWeight {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var permission: Protocol_Permission {
    get {return _permission ?? Protocol_Permission()}
    set {_permission = newValue}
  }
  /// Returns true if `permission` has been explicitly set.
  public var hasPermission: Bool {return self._permission != nil}
  /// Clears the value of `permission`. Subsequent reads from it will return its default value.
  public mutating func clearPermission() {self._permission = nil}

  public var approvedList: [Data] = []

  public var currentWeight: Int64 = 0

  public var result: Protocol_TransactionSignWeight.Result {
    get {return _result ?? Protocol_TransactionSignWeight.Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var transaction: Protocol_TransactionExtention {
    get {return _transaction ?? Protocol_TransactionExtention()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Protocol_TransactionSignWeight.Result.response_code = .enoughPermission

    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum response_code: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case enoughPermission // = 0

      /// error in
      case notEnoughPermission // = 1
      case signatureFormatError // = 2
      case computeAddressError // = 3

      ///The key is not in permission
      case permissionError // = 4
      case otherError // = 20
      case UNRECOGNIZED(Int)

      public init() {
        self = .enoughPermission
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .enoughPermission
        case 1: self = .notEnoughPermission
        case 2: self = .signatureFormatError
        case 3: self = .computeAddressError
        case 4: self = .permissionError
        case 20: self = .otherError
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .enoughPermission: return 0
        case .notEnoughPermission: return 1
        case .signatureFormatError: return 2
        case .computeAddressError: return 3
        case .permissionError: return 4
        case .otherError: return 20
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _permission: Protocol_Permission? = nil
  fileprivate var _result: Protocol_TransactionSignWeight.Result? = nil
  fileprivate var _transaction: Protocol_TransactionExtention? = nil
}

#if swift(>=4.2)

extension Protocol_TransactionSignWeight.Result.response_code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_TransactionSignWeight.Result.response_code] = [
    .enoughPermission,
    .notEnoughPermission,
    .signatureFormatError,
    .computeAddressError,
    .permissionError,
    .otherError,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_TransactionApprovedList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var approvedList: [Data] = []

  public var result: Protocol_TransactionApprovedList.Result {
    get {return _result ?? Protocol_TransactionApprovedList.Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var transaction: Protocol_TransactionExtention {
    get {return _transaction ?? Protocol_TransactionExtention()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var code: Protocol_TransactionApprovedList.Result.response_code = .success

    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum response_code: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case success // = 0
      case signatureFormatError // = 1
      case computeAddressError // = 2
      case otherError // = 20
      case UNRECOGNIZED(Int)

      public init() {
        self = .success
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .success
        case 1: self = .signatureFormatError
        case 2: self = .computeAddressError
        case 20: self = .otherError
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .success: return 0
        case .signatureFormatError: return 1
        case .computeAddressError: return 2
        case .otherError: return 20
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _result: Protocol_TransactionApprovedList.Result? = nil
  fileprivate var _transaction: Protocol_TransactionExtention? = nil
}

#if swift(>=4.2)

extension Protocol_TransactionApprovedList.Result.response_code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_TransactionApprovedList.Result.response_code] = [
    .success,
    .signatureFormatError,
    .computeAddressError,
    .otherError,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_IvkDecryptParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startBlockIndex: Int64 = 0

  public var endBlockIndex: Int64 = 0

  public var ivk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_IvkDecryptAndMarkParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startBlockIndex: Int64 = 0

  public var endBlockIndex: Int64 = 0

  public var ivk: Data = Data()

  public var ak: Data = Data()

  public var nk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_OvkDecryptParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startBlockIndex: Int64 = 0

  public var endBlockIndex: Int64 = 0

  public var ovk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DecryptNotes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var noteTxs: [Protocol_DecryptNotes.NoteTx] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct NoteTx {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var note: Protocol_Note {
      get {return _note ?? Protocol_Note()}
      set {_note = newValue}
    }
    /// Returns true if `note` has been explicitly set.
    public var hasNote: Bool {return self._note != nil}
    /// Clears the value of `note`. Subsequent reads from it will return its default value.
    public mutating func clearNote() {self._note = nil}

    ///transaction id =  sha256(transaction.rowdata)
    public var txid: Data = Data()

    ///the index of note in receive
    public var index: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _note: Protocol_Note? = nil
  }

  public init() {}
}

public struct Protocol_DecryptNotesMarked {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var noteTxs: [Protocol_DecryptNotesMarked.NoteTx] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct NoteTx {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var note: Protocol_Note {
      get {return _note ?? Protocol_Note()}
      set {_note = newValue}
    }
    /// Returns true if `note` has been explicitly set.
    public var hasNote: Bool {return self._note != nil}
    /// Clears the value of `note`. Subsequent reads from it will return its default value.
    public mutating func clearNote() {self._note = nil}

    ///transaction id =  sha256(transaction.rowdata)
    public var txid: Data = Data()

    ///the index of note in receive
    public var index: Int32 = 0

    public var isSpend: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _note: Protocol_Note? = nil
  }

  public init() {}
}

public struct Protocol_Note {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Int64 = 0

  public var paymentAddress: String = String()

  /// random 32
  public var rcm: Data = Data()

  public var memo: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_SpendNote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var note: Protocol_Note {
    get {return _storage._note ?? Protocol_Note()}
    set {_uniqueStorage()._note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return _storage._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {_uniqueStorage()._note = nil}

  /// random number for spend authority signature
  public var alpha: Data {
    get {return _storage._alpha}
    set {_uniqueStorage()._alpha = newValue}
  }

  public var voucher: Protocol_IncrementalMerkleVoucher {
    get {return _storage._voucher ?? Protocol_IncrementalMerkleVoucher()}
    set {_uniqueStorage()._voucher = newValue}
  }
  /// Returns true if `voucher` has been explicitly set.
  public var hasVoucher: Bool {return _storage._voucher != nil}
  /// Clears the value of `voucher`. Subsequent reads from it will return its default value.
  public mutating func clearVoucher() {_uniqueStorage()._voucher = nil}

  /// path for cm from leaf to root in merkle tree
  public var path: Data {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protocol_ReceiveNote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var note: Protocol_Note {
    get {return _note ?? Protocol_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _note: Protocol_Note? = nil
}

public struct Protocol_PrivateParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transparentFromAddress: Data = Data()

  public var ask: Data = Data()

  public var nsk: Data = Data()

  public var ovk: Data = Data()

  public var fromAmount: Int64 = 0

  public var shieldedSpends: [Protocol_SpendNote] = []

  public var shieldedReceives: [Protocol_ReceiveNote] = []

  public var transparentToAddress: Data = Data()

  public var toAmount: Int64 = 0

  /// timeout in seconds, it works only when it bigger than 0
  public var timeout: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_PrivateParametersWithoutAsk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transparentFromAddress: Data = Data()

  public var ak: Data = Data()

  public var nsk: Data = Data()

  public var ovk: Data = Data()

  public var fromAmount: Int64 = 0

  public var shieldedSpends: [Protocol_SpendNote] = []

  public var shieldedReceives: [Protocol_ReceiveNote] = []

  public var transparentToAddress: Data = Data()

  public var toAmount: Int64 = 0

  /// timeout in seconds, it works only when it bigger than 0
  public var timeout: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_SpendAuthSigParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ask: Data = Data()

  public var txHash: Data = Data()

  public var alpha: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_NfParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var note: Protocol_Note {
    get {return _storage._note ?? Protocol_Note()}
    set {_uniqueStorage()._note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return _storage._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {_uniqueStorage()._note = nil}

  public var voucher: Protocol_IncrementalMerkleVoucher {
    get {return _storage._voucher ?? Protocol_IncrementalMerkleVoucher()}
    set {_uniqueStorage()._voucher = newValue}
  }
  /// Returns true if `voucher` has been explicitly set.
  public var hasVoucher: Bool {return _storage._voucher != nil}
  /// Clears the value of `voucher`. Subsequent reads from it will return its default value.
  public mutating func clearVoucher() {_uniqueStorage()._voucher = nil}

  public var ak: Data {
    get {return _storage._ak}
    set {_uniqueStorage()._ak = newValue}
  }

  public var nk: Data {
    get {return _storage._nk}
    set {_uniqueStorage()._nk = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protocol_ExpandedSpendingKeyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ask: Data = Data()

  public var nsk: Data = Data()

  public var ovk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ViewingKeyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ak: Data = Data()

  public var nk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_IncomingViewingKeyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ivk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DiversifierMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var d: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_IncomingViewingKeyDiversifierMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ivk: Protocol_IncomingViewingKeyMessage {
    get {return _ivk ?? Protocol_IncomingViewingKeyMessage()}
    set {_ivk = newValue}
  }
  /// Returns true if `ivk` has been explicitly set.
  public var hasIvk: Bool {return self._ivk != nil}
  /// Clears the value of `ivk`. Subsequent reads from it will return its default value.
  public mutating func clearIvk() {self._ivk = nil}

  public var d: Protocol_DiversifierMessage {
    get {return _d ?? Protocol_DiversifierMessage()}
    set {_d = newValue}
  }
  /// Returns true if `d` has been explicitly set.
  public var hasD: Bool {return self._d != nil}
  /// Clears the value of `d`. Subsequent reads from it will return its default value.
  public mutating func clearD() {self._d = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ivk: Protocol_IncomingViewingKeyMessage? = nil
  fileprivate var _d: Protocol_DiversifierMessage? = nil
}

public struct Protocol_PaymentAddressMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var d: Protocol_DiversifierMessage {
    get {return _d ?? Protocol_DiversifierMessage()}
    set {_d = newValue}
  }
  /// Returns true if `d` has been explicitly set.
  public var hasD: Bool {return self._d != nil}
  /// Clears the value of `d`. Subsequent reads from it will return its default value.
  public mutating func clearD() {self._d = nil}

  public var pkD: Data = Data()

  public var paymentAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _d: Protocol_DiversifierMessage? = nil
}

public struct Protocol_ShieldedAddressInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sk: Data = Data()

  public var ask: Data = Data()

  public var nsk: Data = Data()

  public var ovk: Data = Data()

  public var ak: Data = Data()

  public var nk: Data = Data()

  public var ivk: Data = Data()

  public var d: Data = Data()

  public var pkD: Data = Data()

  public var paymentAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_NoteParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ak: Data = Data()

  public var nk: Data = Data()

  public var note: Protocol_Note {
    get {return _note ?? Protocol_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var txid: Data = Data()

  public var index: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _note: Protocol_Note? = nil
}

public struct Protocol_SpendResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Bool = false

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TransactionInfoList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionInfo: [Protocol_TransactionInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_SpendNoteTRC20 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var note: Protocol_Note {
    get {return _note ?? Protocol_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var alpha: Data = Data()

  public var root: Data = Data()

  public var path: Data = Data()

  public var pos: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _note: Protocol_Note? = nil
}

public struct Protocol_PrivateShieldedTRC20Parameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ask: Data = Data()

  public var nsk: Data = Data()

  public var ovk: Data = Data()

  public var fromAmount: String = String()

  public var shieldedSpends: [Protocol_SpendNoteTRC20] = []

  public var shieldedReceives: [Protocol_ReceiveNote] = []

  public var transparentToAddress: Data = Data()

  public var toAmount: String = String()

  public var shieldedTrc20ContractAddress: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_PrivateShieldedTRC20ParametersWithoutAsk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ak: Data = Data()

  public var nsk: Data = Data()

  public var ovk: Data = Data()

  public var fromAmount: String = String()

  public var shieldedSpends: [Protocol_SpendNoteTRC20] = []

  public var shieldedReceives: [Protocol_ReceiveNote] = []

  public var transparentToAddress: Data = Data()

  public var toAmount: String = String()

  public var shieldedTrc20ContractAddress: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ShieldedTRC20Parameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spendDescription: [Protocol_SpendDescription] = []

  public var receiveDescription: [Protocol_ReceiveDescription] = []

  public var bindingSignature: Data = Data()

  public var messageHash: Data = Data()

  public var triggerContractInput: String = String()

  public var parameterType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_IvkDecryptTRC20Parameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startBlockIndex: Int64 = 0

  public var endBlockIndex: Int64 = 0

  public var shieldedTrc20ContractAddress: Data = Data()

  public var ivk: Data = Data()

  public var ak: Data = Data()

  public var nk: Data = Data()

  public var events: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_OvkDecryptTRC20Parameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startBlockIndex: Int64 = 0

  public var endBlockIndex: Int64 = 0

  public var ovk: Data = Data()

  public var shieldedTrc20ContractAddress: Data = Data()

  public var events: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DecryptNotesTRC20 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var noteTxs: [Protocol_DecryptNotesTRC20.NoteTx] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct NoteTx {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var note: Protocol_Note {
      get {return _note ?? Protocol_Note()}
      set {_note = newValue}
    }
    /// Returns true if `note` has been explicitly set.
    public var hasNote: Bool {return self._note != nil}
    /// Clears the value of `note`. Subsequent reads from it will return its default value.
    public mutating func clearNote() {self._note = nil}

    public var position: Int64 = 0

    public var isSpent: Bool = false

    public var txid: Data = Data()

    ///the index of note in txid
    public var index: Int32 = 0

    public var toAmount: String = String()

    public var transparentToAddress: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _note: Protocol_Note? = nil
  }

  public init() {}
}

public struct Protocol_NfTRC20Parameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var note: Protocol_Note {
    get {return _note ?? Protocol_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var ak: Data = Data()

  public var nk: Data = Data()

  public var position: Int64 = 0

  public var shieldedTrc20ContractAddress: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _note: Protocol_Note? = nil
}

public struct Protocol_NullifierResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isSpent: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ShieldedTRC20TriggerContractParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shieldedTrc20Parameters: Protocol_ShieldedTRC20Parameters {
    get {return _shieldedTrc20Parameters ?? Protocol_ShieldedTRC20Parameters()}
    set {_shieldedTrc20Parameters = newValue}
  }
  /// Returns true if `shieldedTrc20Parameters` has been explicitly set.
  public var hasShieldedTrc20Parameters: Bool {return self._shieldedTrc20Parameters != nil}
  /// Clears the value of `shieldedTrc20Parameters`. Subsequent reads from it will return its default value.
  public mutating func clearShieldedTrc20Parameters() {self._shieldedTrc20Parameters = nil}

  public var spendAuthoritySignature: [Protocol_BytesMessage] = []

  public var amount: String = String()

  public var transparentToAddress: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shieldedTrc20Parameters: Protocol_ShieldedTRC20Parameters? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Protocol_Return: @unchecked Sendable {}
extension Protocol_Return.response_code: @unchecked Sendable {}
extension Protocol_BlockReference: @unchecked Sendable {}
extension Protocol_WitnessList: @unchecked Sendable {}
extension Protocol_ProposalList: @unchecked Sendable {}
extension Protocol_ExchangeList: @unchecked Sendable {}
extension Protocol_AssetIssueList: @unchecked Sendable {}
extension Protocol_BlockList: @unchecked Sendable {}
extension Protocol_TransactionList: @unchecked Sendable {}
extension Protocol_TransactionIdList: @unchecked Sendable {}
extension Protocol_DelegatedResourceMessage: @unchecked Sendable {}
extension Protocol_DelegatedResourceList: @unchecked Sendable {}
extension Protocol_GetAvailableUnfreezeCountRequestMessage: @unchecked Sendable {}
extension Protocol_GetAvailableUnfreezeCountResponseMessage: @unchecked Sendable {}
extension Protocol_CanDelegatedMaxSizeRequestMessage: @unchecked Sendable {}
extension Protocol_CanDelegatedMaxSizeResponseMessage: @unchecked Sendable {}
extension Protocol_CanWithdrawUnfreezeAmountRequestMessage: @unchecked Sendable {}
extension Protocol_CanWithdrawUnfreezeAmountResponseMessage: @unchecked Sendable {}
extension Protocol_NodeList: @unchecked Sendable {}
extension Protocol_Node: @unchecked Sendable {}
extension Protocol_Address: @unchecked Sendable {}
extension Protocol_EmptyMessage: @unchecked Sendable {}
extension Protocol_NumberMessage: @unchecked Sendable {}
extension Protocol_BytesMessage: @unchecked Sendable {}
extension Protocol_TimeMessage: @unchecked Sendable {}
extension Protocol_BlockReq: @unchecked Sendable {}
extension Protocol_BlockLimit: @unchecked Sendable {}
extension Protocol_TransactionLimit: @unchecked Sendable {}
extension Protocol_AccountPaginated: @unchecked Sendable {}
extension Protocol_TimePaginatedMessage: @unchecked Sendable {}
extension Protocol_AccountNetMessage: @unchecked Sendable {}
extension Protocol_AccountResourceMessage: @unchecked Sendable {}
extension Protocol_PaginatedMessage: @unchecked Sendable {}
extension Protocol_EasyTransferMessage: @unchecked Sendable {}
extension Protocol_EasyTransferAssetMessage: @unchecked Sendable {}
extension Protocol_EasyTransferByPrivateMessage: @unchecked Sendable {}
extension Protocol_EasyTransferAssetByPrivateMessage: @unchecked Sendable {}
extension Protocol_EasyTransferResponse: @unchecked Sendable {}
extension Protocol_AddressPrKeyPairMessage: @unchecked Sendable {}
extension Protocol_TransactionExtention: @unchecked Sendable {}
extension Protocol_EstimateEnergyMessage: @unchecked Sendable {}
extension Protocol_BlockExtention: @unchecked Sendable {}
extension Protocol_BlockListExtention: @unchecked Sendable {}
extension Protocol_TransactionListExtention: @unchecked Sendable {}
extension Protocol_BlockIncrementalMerkleTree: @unchecked Sendable {}
extension Protocol_TransactionSignWeight: @unchecked Sendable {}
extension Protocol_TransactionSignWeight.Result: @unchecked Sendable {}
extension Protocol_TransactionSignWeight.Result.response_code: @unchecked Sendable {}
extension Protocol_TransactionApprovedList: @unchecked Sendable {}
extension Protocol_TransactionApprovedList.Result: @unchecked Sendable {}
extension Protocol_TransactionApprovedList.Result.response_code: @unchecked Sendable {}
extension Protocol_IvkDecryptParameters: @unchecked Sendable {}
extension Protocol_IvkDecryptAndMarkParameters: @unchecked Sendable {}
extension Protocol_OvkDecryptParameters: @unchecked Sendable {}
extension Protocol_DecryptNotes: @unchecked Sendable {}
extension Protocol_DecryptNotes.NoteTx: @unchecked Sendable {}
extension Protocol_DecryptNotesMarked: @unchecked Sendable {}
extension Protocol_DecryptNotesMarked.NoteTx: @unchecked Sendable {}
extension Protocol_Note: @unchecked Sendable {}
extension Protocol_SpendNote: @unchecked Sendable {}
extension Protocol_ReceiveNote: @unchecked Sendable {}
extension Protocol_PrivateParameters: @unchecked Sendable {}
extension Protocol_PrivateParametersWithoutAsk: @unchecked Sendable {}
extension Protocol_SpendAuthSigParameters: @unchecked Sendable {}
extension Protocol_NfParameters: @unchecked Sendable {}
extension Protocol_ExpandedSpendingKeyMessage: @unchecked Sendable {}
extension Protocol_ViewingKeyMessage: @unchecked Sendable {}
extension Protocol_IncomingViewingKeyMessage: @unchecked Sendable {}
extension Protocol_DiversifierMessage: @unchecked Sendable {}
extension Protocol_IncomingViewingKeyDiversifierMessage: @unchecked Sendable {}
extension Protocol_PaymentAddressMessage: @unchecked Sendable {}
extension Protocol_ShieldedAddressInfo: @unchecked Sendable {}
extension Protocol_NoteParameters: @unchecked Sendable {}
extension Protocol_SpendResult: @unchecked Sendable {}
extension Protocol_TransactionInfoList: @unchecked Sendable {}
extension Protocol_SpendNoteTRC20: @unchecked Sendable {}
extension Protocol_PrivateShieldedTRC20Parameters: @unchecked Sendable {}
extension Protocol_PrivateShieldedTRC20ParametersWithoutAsk: @unchecked Sendable {}
extension Protocol_ShieldedTRC20Parameters: @unchecked Sendable {}
extension Protocol_IvkDecryptTRC20Parameters: @unchecked Sendable {}
extension Protocol_OvkDecryptTRC20Parameters: @unchecked Sendable {}
extension Protocol_DecryptNotesTRC20: @unchecked Sendable {}
extension Protocol_DecryptNotesTRC20.NoteTx: @unchecked Sendable {}
extension Protocol_NfTRC20Parameters: @unchecked Sendable {}
extension Protocol_NullifierResult: @unchecked Sendable {}
extension Protocol_ShieldedTRC20TriggerContractParameters: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_Return: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Return"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "code"),
    3: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    if self.code != .success {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Return, rhs: Protocol_Return) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Return.response_code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "SIGERROR"),
    2: .same(proto: "CONTRACT_VALIDATE_ERROR"),
    3: .same(proto: "CONTRACT_EXE_ERROR"),
    4: .same(proto: "BANDWITH_ERROR"),
    5: .same(proto: "DUP_TRANSACTION_ERROR"),
    6: .same(proto: "TAPOS_ERROR"),
    7: .same(proto: "TOO_BIG_TRANSACTION_ERROR"),
    8: .same(proto: "TRANSACTION_EXPIRATION_ERROR"),
    9: .same(proto: "SERVER_BUSY"),
    10: .same(proto: "NO_CONNECTION"),
    11: .same(proto: "NOT_ENOUGH_EFFECTIVE_CONNECTION"),
    20: .same(proto: "OTHER_ERROR"),
  ]
}

extension Protocol_BlockReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_num"),
    2: .standard(proto: "block_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.blockNum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blockHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.blockNum, fieldNumber: 1)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockReference, rhs: Protocol_BlockReference) -> Bool {
    if lhs.blockNum != rhs.blockNum {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_WitnessList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WitnessList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "witnesses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.witnesses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.witnesses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.witnesses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_WitnessList, rhs: Protocol_WitnessList) -> Bool {
    if lhs.witnesses != rhs.witnesses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ProposalList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposals"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.proposals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.proposals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.proposals, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ProposalList, rhs: Protocol_ProposalList) -> Bool {
    if lhs.proposals != rhs.proposals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ExchangeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exchanges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.exchanges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exchanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exchanges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ExchangeList, rhs: Protocol_ExchangeList) -> Bool {
    if lhs.exchanges != rhs.exchanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_AssetIssueList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetIssueList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assetIssue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assetIssue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetIssue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assetIssue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_AssetIssueList, rhs: Protocol_AssetIssueList) -> Bool {
    if lhs.assetIssue != rhs.assetIssue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.block) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.block.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.block, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockList, rhs: Protocol_BlockList) -> Bool {
    if lhs.block != rhs.block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionList, rhs: Protocol_TransactionList) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionIdList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionIdList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.txID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.txID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionIdList, rhs: Protocol_TransactionIdList) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DelegatedResourceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatedResourceMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromAddress"),
    2: .same(proto: "toAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fromAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.toAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fromAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.fromAddress, fieldNumber: 1)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DelegatedResourceMessage, rhs: Protocol_DelegatedResourceMessage) -> Bool {
    if lhs.fromAddress != rhs.fromAddress {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DelegatedResourceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatedResourceList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegatedResource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.delegatedResource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delegatedResource.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delegatedResource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DelegatedResourceList, rhs: Protocol_DelegatedResourceList) -> Bool {
    if lhs.delegatedResource != rhs.delegatedResource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_GetAvailableUnfreezeCountRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAvailableUnfreezeCountRequestMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ownerAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_GetAvailableUnfreezeCountRequestMessage, rhs: Protocol_GetAvailableUnfreezeCountRequestMessage) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_GetAvailableUnfreezeCountResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAvailableUnfreezeCountResponseMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_GetAvailableUnfreezeCountResponseMessage, rhs: Protocol_GetAvailableUnfreezeCountResponseMessage) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_CanDelegatedMaxSizeRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanDelegatedMaxSizeRequestMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "owner_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ownerAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_CanDelegatedMaxSizeRequestMessage, rhs: Protocol_CanDelegatedMaxSizeRequestMessage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_CanDelegatedMaxSizeResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanDelegatedMaxSizeResponseMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxSize != 0 {
      try visitor.visitSingularInt64Field(value: self.maxSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_CanDelegatedMaxSizeResponseMessage, rhs: Protocol_CanDelegatedMaxSizeResponseMessage) -> Bool {
    if lhs.maxSize != rhs.maxSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_CanWithdrawUnfreezeAmountRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanWithdrawUnfreezeAmountRequestMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ownerAddress) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_CanWithdrawUnfreezeAmountRequestMessage, rhs: Protocol_CanWithdrawUnfreezeAmountRequestMessage) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_CanWithdrawUnfreezeAmountResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanWithdrawUnfreezeAmountResponseMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_CanWithdrawUnfreezeAmountResponseMessage, rhs: Protocol_CanWithdrawUnfreezeAmountResponseMessage) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeList, rhs: Protocol_NodeList) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Node, rhs: Protocol_Node) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Address"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularBytesField(value: self.host, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Address, rhs: Protocol_Address) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_EmptyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmptyMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_EmptyMessage, rhs: Protocol_EmptyMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NumberMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumberMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.num) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.num != 0 {
      try visitor.visitSingularInt64Field(value: self.num, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NumberMessage, rhs: Protocol_NumberMessage) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BytesMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BytesMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BytesMessage, rhs: Protocol_BytesMessage) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TimeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beginInMilliseconds"),
    2: .same(proto: "endInMilliseconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.beginInMilliseconds) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endInMilliseconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.beginInMilliseconds != 0 {
      try visitor.visitSingularInt64Field(value: self.beginInMilliseconds, fieldNumber: 1)
    }
    if self.endInMilliseconds != 0 {
      try visitor.visitSingularInt64Field(value: self.endInMilliseconds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TimeMessage, rhs: Protocol_TimeMessage) -> Bool {
    if lhs.beginInMilliseconds != rhs.beginInMilliseconds {return false}
    if lhs.endInMilliseconds != rhs.endInMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_or_num"),
    2: .same(proto: "detail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idOrNum) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idOrNum.isEmpty {
      try visitor.visitSingularStringField(value: self.idOrNum, fieldNumber: 1)
    }
    if self.detail != false {
      try visitor.visitSingularBoolField(value: self.detail, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockReq, rhs: Protocol_BlockReq) -> Bool {
    if lhs.idOrNum != rhs.idOrNum {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startNum"),
    2: .same(proto: "endNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startNum != 0 {
      try visitor.visitSingularInt64Field(value: self.startNum, fieldNumber: 1)
    }
    if self.endNum != 0 {
      try visitor.visitSingularInt64Field(value: self.endNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockLimit, rhs: Protocol_BlockLimit) -> Bool {
    if lhs.startNum != rhs.startNum {return false}
    if lhs.endNum != rhs.endNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionId"),
    2: .same(proto: "limitNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.limitNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.transactionID, fieldNumber: 1)
    }
    if self.limitNum != 0 {
      try visitor.visitSingularInt64Field(value: self.limitNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionLimit, rhs: Protocol_TransactionLimit) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.limitNum != rhs.limitNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_AccountPaginated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountPaginated"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "offset"),
    3: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_AccountPaginated, rhs: Protocol_AccountPaginated) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TimePaginatedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimePaginatedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeMessage"),
    2: .same(proto: "offset"),
    3: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeMessage) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TimePaginatedMessage, rhs: Protocol_TimePaginatedMessage) -> Bool {
    if lhs._timeMessage != rhs._timeMessage {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_AccountNetMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountNetMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "freeNetUsed"),
    2: .same(proto: "freeNetLimit"),
    3: .same(proto: "NetUsed"),
    4: .same(proto: "NetLimit"),
    5: .same(proto: "assetNetUsed"),
    6: .same(proto: "assetNetLimit"),
    7: .same(proto: "TotalNetLimit"),
    8: .same(proto: "TotalNetWeight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.freeNetUsed) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.freeNetLimit) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.netUsed) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.netLimit) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &self.assetNetUsed) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &self.assetNetLimit) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.totalNetLimit) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.totalNetWeight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.freeNetUsed != 0 {
      try visitor.visitSingularInt64Field(value: self.freeNetUsed, fieldNumber: 1)
    }
    if self.freeNetLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.freeNetLimit, fieldNumber: 2)
    }
    if self.netUsed != 0 {
      try visitor.visitSingularInt64Field(value: self.netUsed, fieldNumber: 3)
    }
    if self.netLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.netLimit, fieldNumber: 4)
    }
    if !self.assetNetUsed.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: self.assetNetUsed, fieldNumber: 5)
    }
    if !self.assetNetLimit.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: self.assetNetLimit, fieldNumber: 6)
    }
    if self.totalNetLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.totalNetLimit, fieldNumber: 7)
    }
    if self.totalNetWeight != 0 {
      try visitor.visitSingularInt64Field(value: self.totalNetWeight, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_AccountNetMessage, rhs: Protocol_AccountNetMessage) -> Bool {
    if lhs.freeNetUsed != rhs.freeNetUsed {return false}
    if lhs.freeNetLimit != rhs.freeNetLimit {return false}
    if lhs.netUsed != rhs.netUsed {return false}
    if lhs.netLimit != rhs.netLimit {return false}
    if lhs.assetNetUsed != rhs.assetNetUsed {return false}
    if lhs.assetNetLimit != rhs.assetNetLimit {return false}
    if lhs.totalNetLimit != rhs.totalNetLimit {return false}
    if lhs.totalNetWeight != rhs.totalNetWeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_AccountResourceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountResourceMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "freeNetUsed"),
    2: .same(proto: "freeNetLimit"),
    3: .same(proto: "NetUsed"),
    4: .same(proto: "NetLimit"),
    5: .same(proto: "assetNetUsed"),
    6: .same(proto: "assetNetLimit"),
    7: .same(proto: "TotalNetLimit"),
    8: .same(proto: "TotalNetWeight"),
    9: .same(proto: "TotalTronPowerWeight"),
    10: .same(proto: "tronPowerUsed"),
    11: .same(proto: "tronPowerLimit"),
    13: .same(proto: "EnergyUsed"),
    14: .same(proto: "EnergyLimit"),
    15: .same(proto: "TotalEnergyLimit"),
    16: .same(proto: "TotalEnergyWeight"),
    21: .same(proto: "storageUsed"),
    22: .same(proto: "storageLimit"),
  ]

  fileprivate class _StorageClass {
    var _freeNetUsed: Int64 = 0
    var _freeNetLimit: Int64 = 0
    var _netUsed: Int64 = 0
    var _netLimit: Int64 = 0
    var _assetNetUsed: Dictionary<String,Int64> = [:]
    var _assetNetLimit: Dictionary<String,Int64> = [:]
    var _totalNetLimit: Int64 = 0
    var _totalNetWeight: Int64 = 0
    var _totalTronPowerWeight: Int64 = 0
    var _tronPowerUsed: Int64 = 0
    var _tronPowerLimit: Int64 = 0
    var _energyUsed: Int64 = 0
    var _energyLimit: Int64 = 0
    var _totalEnergyLimit: Int64 = 0
    var _totalEnergyWeight: Int64 = 0
    var _storageUsed: Int64 = 0
    var _storageLimit: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _freeNetUsed = source._freeNetUsed
      _freeNetLimit = source._freeNetLimit
      _netUsed = source._netUsed
      _netLimit = source._netLimit
      _assetNetUsed = source._assetNetUsed
      _assetNetLimit = source._assetNetLimit
      _totalNetLimit = source._totalNetLimit
      _totalNetWeight = source._totalNetWeight
      _totalTronPowerWeight = source._totalTronPowerWeight
      _tronPowerUsed = source._tronPowerUsed
      _tronPowerLimit = source._tronPowerLimit
      _energyUsed = source._energyUsed
      _energyLimit = source._energyLimit
      _totalEnergyLimit = source._totalEnergyLimit
      _totalEnergyWeight = source._totalEnergyWeight
      _storageUsed = source._storageUsed
      _storageLimit = source._storageLimit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._freeNetUsed) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._freeNetLimit) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._netUsed) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._netLimit) }()
        case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._assetNetUsed) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._assetNetLimit) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._totalNetLimit) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._totalNetWeight) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._totalTronPowerWeight) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._tronPowerUsed) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._tronPowerLimit) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._energyUsed) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._energyLimit) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._totalEnergyLimit) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._totalEnergyWeight) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._storageUsed) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._storageLimit) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._freeNetUsed != 0 {
        try visitor.visitSingularInt64Field(value: _storage._freeNetUsed, fieldNumber: 1)
      }
      if _storage._freeNetLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._freeNetLimit, fieldNumber: 2)
      }
      if _storage._netUsed != 0 {
        try visitor.visitSingularInt64Field(value: _storage._netUsed, fieldNumber: 3)
      }
      if _storage._netLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._netLimit, fieldNumber: 4)
      }
      if !_storage._assetNetUsed.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._assetNetUsed, fieldNumber: 5)
      }
      if !_storage._assetNetLimit.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._assetNetLimit, fieldNumber: 6)
      }
      if _storage._totalNetLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalNetLimit, fieldNumber: 7)
      }
      if _storage._totalNetWeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalNetWeight, fieldNumber: 8)
      }
      if _storage._totalTronPowerWeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalTronPowerWeight, fieldNumber: 9)
      }
      if _storage._tronPowerUsed != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tronPowerUsed, fieldNumber: 10)
      }
      if _storage._tronPowerLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tronPowerLimit, fieldNumber: 11)
      }
      if _storage._energyUsed != 0 {
        try visitor.visitSingularInt64Field(value: _storage._energyUsed, fieldNumber: 13)
      }
      if _storage._energyLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._energyLimit, fieldNumber: 14)
      }
      if _storage._totalEnergyLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalEnergyLimit, fieldNumber: 15)
      }
      if _storage._totalEnergyWeight != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalEnergyWeight, fieldNumber: 16)
      }
      if _storage._storageUsed != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storageUsed, fieldNumber: 21)
      }
      if _storage._storageLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storageLimit, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_AccountResourceMessage, rhs: Protocol_AccountResourceMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._freeNetUsed != rhs_storage._freeNetUsed {return false}
        if _storage._freeNetLimit != rhs_storage._freeNetLimit {return false}
        if _storage._netUsed != rhs_storage._netUsed {return false}
        if _storage._netLimit != rhs_storage._netLimit {return false}
        if _storage._assetNetUsed != rhs_storage._assetNetUsed {return false}
        if _storage._assetNetLimit != rhs_storage._assetNetLimit {return false}
        if _storage._totalNetLimit != rhs_storage._totalNetLimit {return false}
        if _storage._totalNetWeight != rhs_storage._totalNetWeight {return false}
        if _storage._totalTronPowerWeight != rhs_storage._totalTronPowerWeight {return false}
        if _storage._tronPowerUsed != rhs_storage._tronPowerUsed {return false}
        if _storage._tronPowerLimit != rhs_storage._tronPowerLimit {return false}
        if _storage._energyUsed != rhs_storage._energyUsed {return false}
        if _storage._energyLimit != rhs_storage._energyLimit {return false}
        if _storage._totalEnergyLimit != rhs_storage._totalEnergyLimit {return false}
        if _storage._totalEnergyWeight != rhs_storage._totalEnergyWeight {return false}
        if _storage._storageUsed != rhs_storage._storageUsed {return false}
        if _storage._storageLimit != rhs_storage._storageLimit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PaginatedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaginatedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PaginatedMessage, rhs: Protocol_PaginatedMessage) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_EasyTransferMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EasyTransferMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "passPhrase"),
    2: .same(proto: "toAddress"),
    3: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.passPhrase) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.toAddress) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.passPhrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.passPhrase, fieldNumber: 1)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_EasyTransferMessage, rhs: Protocol_EasyTransferMessage) -> Bool {
    if lhs.passPhrase != rhs.passPhrase {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_EasyTransferAssetMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EasyTransferAssetMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "passPhrase"),
    2: .same(proto: "toAddress"),
    3: .same(proto: "assetId"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.passPhrase) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.toAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.assetID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.passPhrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.passPhrase, fieldNumber: 1)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 2)
    }
    if !self.assetID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetID, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_EasyTransferAssetMessage, rhs: Protocol_EasyTransferAssetMessage) -> Bool {
    if lhs.passPhrase != rhs.passPhrase {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_EasyTransferByPrivateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EasyTransferByPrivateMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "privateKey"),
    2: .same(proto: "toAddress"),
    3: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.toAddress) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 1)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_EasyTransferByPrivateMessage, rhs: Protocol_EasyTransferByPrivateMessage) -> Bool {
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_EasyTransferAssetByPrivateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EasyTransferAssetByPrivateMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "privateKey"),
    2: .same(proto: "toAddress"),
    3: .same(proto: "assetId"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.toAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.assetID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 1)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 2)
    }
    if !self.assetID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetID, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_EasyTransferAssetByPrivateMessage, rhs: Protocol_EasyTransferAssetByPrivateMessage) -> Bool {
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.assetID != rhs.assetID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_EasyTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EasyTransferResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "result"),
    3: .same(proto: "txid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_EasyTransferResponse, rhs: Protocol_EasyTransferResponse) -> Bool {
    if lhs._transaction != rhs._transaction {return false}
    if lhs._result != rhs._result {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_AddressPrKeyPairMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressPrKeyPairMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "privateKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.privateKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_AddressPrKeyPairMessage, rhs: Protocol_AddressPrKeyPairMessage) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionExtention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionExtention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "txid"),
    3: .standard(proto: "constant_result"),
    4: .same(proto: "result"),
    5: .standard(proto: "energy_used"),
    6: .same(proto: "logs"),
    7: .standard(proto: "internal_transactions"),
    8: .standard(proto: "energy_penalty"),
  ]

  fileprivate class _StorageClass {
    var _transaction: Protocol_Transaction? = nil
    var _txid: Data = Data()
    var _constantResult: [Data] = []
    var _result: Protocol_Return? = nil
    var _energyUsed: Int64 = 0
    var _logs: [Protocol_TransactionInfo.Log] = []
    var _internalTransactions: [Protocol_InternalTransaction] = []
    var _energyPenalty: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transaction = source._transaction
      _txid = source._txid
      _constantResult = source._constantResult
      _result = source._result
      _energyUsed = source._energyUsed
      _logs = source._logs
      _internalTransactions = source._internalTransactions
      _energyPenalty = source._energyPenalty
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._transaction) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._txid) }()
        case 3: try { try decoder.decodeRepeatedBytesField(value: &_storage._constantResult) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._result) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._energyUsed) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._logs) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._internalTransactions) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._energyPenalty) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._transaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._txid.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._txid, fieldNumber: 2)
      }
      if !_storage._constantResult.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._constantResult, fieldNumber: 3)
      }
      try { if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._energyUsed != 0 {
        try visitor.visitSingularInt64Field(value: _storage._energyUsed, fieldNumber: 5)
      }
      if !_storage._logs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._logs, fieldNumber: 6)
      }
      if !_storage._internalTransactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._internalTransactions, fieldNumber: 7)
      }
      if _storage._energyPenalty != 0 {
        try visitor.visitSingularInt64Field(value: _storage._energyPenalty, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionExtention, rhs: Protocol_TransactionExtention) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._txid != rhs_storage._txid {return false}
        if _storage._constantResult != rhs_storage._constantResult {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._energyUsed != rhs_storage._energyUsed {return false}
        if _storage._logs != rhs_storage._logs {return false}
        if _storage._internalTransactions != rhs_storage._internalTransactions {return false}
        if _storage._energyPenalty != rhs_storage._energyPenalty {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_EstimateEnergyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EstimateEnergyMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "energy_required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.energyRequired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.energyRequired != 0 {
      try visitor.visitSingularInt64Field(value: self.energyRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_EstimateEnergyMessage, rhs: Protocol_EstimateEnergyMessage) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.energyRequired != rhs.energyRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockExtention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockExtention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "block_header"),
    3: .same(proto: "blockid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockHeader) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.blockid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try { if let v = self._blockHeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.blockid.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockExtention, rhs: Protocol_BlockExtention) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs._blockHeader != rhs._blockHeader {return false}
    if lhs.blockid != rhs.blockid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockListExtention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockListExtention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.block) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.block.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.block, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockListExtention, rhs: Protocol_BlockListExtention) -> Bool {
    if lhs.block != rhs.block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionListExtention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionListExtention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionListExtention, rhs: Protocol_TransactionListExtention) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockIncrementalMerkleTree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockIncrementalMerkleTree"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "merkleTree"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.number) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._merkleTree) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 1)
    }
    try { if let v = self._merkleTree {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockIncrementalMerkleTree, rhs: Protocol_BlockIncrementalMerkleTree) -> Bool {
    if lhs.number != rhs.number {return false}
    if lhs._merkleTree != rhs._merkleTree {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionSignWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionSignWeight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permission"),
    2: .standard(proto: "approved_list"),
    3: .standard(proto: "current_weight"),
    4: .same(proto: "result"),
    5: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._permission) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.approvedList) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.currentWeight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._permission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.approvedList.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.approvedList, fieldNumber: 2)
    }
    if self.currentWeight != 0 {
      try visitor.visitSingularInt64Field(value: self.currentWeight, fieldNumber: 3)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionSignWeight, rhs: Protocol_TransactionSignWeight) -> Bool {
    if lhs._permission != rhs._permission {return false}
    if lhs.approvedList != rhs.approvedList {return false}
    if lhs.currentWeight != rhs.currentWeight {return false}
    if lhs._result != rhs._result {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionSignWeight.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_TransactionSignWeight.protoMessageName + ".Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .enoughPermission {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionSignWeight.Result, rhs: Protocol_TransactionSignWeight.Result) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionSignWeight.Result.response_code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENOUGH_PERMISSION"),
    1: .same(proto: "NOT_ENOUGH_PERMISSION"),
    2: .same(proto: "SIGNATURE_FORMAT_ERROR"),
    3: .same(proto: "COMPUTE_ADDRESS_ERROR"),
    4: .same(proto: "PERMISSION_ERROR"),
    20: .same(proto: "OTHER_ERROR"),
  ]
}

extension Protocol_TransactionApprovedList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionApprovedList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "approved_list"),
    4: .same(proto: "result"),
    5: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.approvedList) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.approvedList.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.approvedList, fieldNumber: 2)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionApprovedList, rhs: Protocol_TransactionApprovedList) -> Bool {
    if lhs.approvedList != rhs.approvedList {return false}
    if lhs._result != rhs._result {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionApprovedList.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_TransactionApprovedList.protoMessageName + ".Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .success {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionApprovedList.Result, rhs: Protocol_TransactionApprovedList.Result) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionApprovedList.Result.response_code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "SIGNATURE_FORMAT_ERROR"),
    2: .same(proto: "COMPUTE_ADDRESS_ERROR"),
    20: .same(proto: "OTHER_ERROR"),
  ]
}

extension Protocol_IvkDecryptParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IvkDecryptParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_block_index"),
    2: .standard(proto: "end_block_index"),
    3: .same(proto: "ivk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startBlockIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endBlockIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ivk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.startBlockIndex, fieldNumber: 1)
    }
    if self.endBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.endBlockIndex, fieldNumber: 2)
    }
    if !self.ivk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ivk, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_IvkDecryptParameters, rhs: Protocol_IvkDecryptParameters) -> Bool {
    if lhs.startBlockIndex != rhs.startBlockIndex {return false}
    if lhs.endBlockIndex != rhs.endBlockIndex {return false}
    if lhs.ivk != rhs.ivk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_IvkDecryptAndMarkParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IvkDecryptAndMarkParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_block_index"),
    2: .standard(proto: "end_block_index"),
    5: .same(proto: "ivk"),
    3: .same(proto: "ak"),
    4: .same(proto: "nk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startBlockIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endBlockIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nk) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.ivk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.startBlockIndex, fieldNumber: 1)
    }
    if self.endBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.endBlockIndex, fieldNumber: 2)
    }
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 3)
    }
    if !self.nk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nk, fieldNumber: 4)
    }
    if !self.ivk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ivk, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_IvkDecryptAndMarkParameters, rhs: Protocol_IvkDecryptAndMarkParameters) -> Bool {
    if lhs.startBlockIndex != rhs.startBlockIndex {return false}
    if lhs.endBlockIndex != rhs.endBlockIndex {return false}
    if lhs.ivk != rhs.ivk {return false}
    if lhs.ak != rhs.ak {return false}
    if lhs.nk != rhs.nk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_OvkDecryptParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OvkDecryptParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_block_index"),
    2: .standard(proto: "end_block_index"),
    3: .same(proto: "ovk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startBlockIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endBlockIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ovk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.startBlockIndex, fieldNumber: 1)
    }
    if self.endBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.endBlockIndex, fieldNumber: 2)
    }
    if !self.ovk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovk, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_OvkDecryptParameters, rhs: Protocol_OvkDecryptParameters) -> Bool {
    if lhs.startBlockIndex != rhs.startBlockIndex {return false}
    if lhs.endBlockIndex != rhs.endBlockIndex {return false}
    if lhs.ovk != rhs.ovk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DecryptNotes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptNotes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "noteTxs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.noteTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.noteTxs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noteTxs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DecryptNotes, rhs: Protocol_DecryptNotes) -> Bool {
    if lhs.noteTxs != rhs.noteTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DecryptNotes.NoteTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_DecryptNotes.protoMessageName + ".NoteTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    2: .same(proto: "txid"),
    3: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DecryptNotes.NoteTx, rhs: Protocol_DecryptNotes.NoteTx) -> Bool {
    if lhs._note != rhs._note {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DecryptNotesMarked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptNotesMarked"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "noteTxs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.noteTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.noteTxs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noteTxs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DecryptNotesMarked, rhs: Protocol_DecryptNotesMarked) -> Bool {
    if lhs.noteTxs != rhs.noteTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DecryptNotesMarked.NoteTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_DecryptNotesMarked.protoMessageName + ".NoteTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    2: .same(proto: "txid"),
    3: .same(proto: "index"),
    4: .standard(proto: "is_spend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSpend) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 3)
    }
    if self.isSpend != false {
      try visitor.visitSingularBoolField(value: self.isSpend, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DecryptNotesMarked.NoteTx, rhs: Protocol_DecryptNotesMarked.NoteTx) -> Bool {
    if lhs._note != rhs._note {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.index != rhs.index {return false}
    if lhs.isSpend != rhs.isSpend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Note: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Note"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "payment_address"),
    3: .same(proto: "rcm"),
    4: .same(proto: "memo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.paymentAddress) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.rcm) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.memo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    if !self.paymentAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentAddress, fieldNumber: 2)
    }
    if !self.rcm.isEmpty {
      try visitor.visitSingularBytesField(value: self.rcm, fieldNumber: 3)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularBytesField(value: self.memo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Note, rhs: Protocol_Note) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.paymentAddress != rhs.paymentAddress {return false}
    if lhs.rcm != rhs.rcm {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SpendNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "note"),
    4: .same(proto: "alpha"),
    5: .same(proto: "voucher"),
    6: .same(proto: "path"),
  ]

  fileprivate class _StorageClass {
    var _note: Protocol_Note? = nil
    var _alpha: Data = Data()
    var _voucher: Protocol_IncrementalMerkleVoucher? = nil
    var _path: Data = Data()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _note = source._note
      _alpha = source._alpha
      _voucher = source._voucher
      _path = source._path
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._note) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._alpha) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._voucher) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._path) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._note {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._alpha.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._alpha, fieldNumber: 4)
      }
      try { if let v = _storage._voucher {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._path.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._path, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_SpendNote, rhs: Protocol_SpendNote) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._note != rhs_storage._note {return false}
        if _storage._alpha != rhs_storage._alpha {return false}
        if _storage._voucher != rhs_storage._voucher {return false}
        if _storage._path != rhs_storage._path {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ReceiveNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiveNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ReceiveNote, rhs: Protocol_ReceiveNote) -> Bool {
    if lhs._note != rhs._note {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PrivateParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivateParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transparent_from_address"),
    2: .same(proto: "ask"),
    3: .same(proto: "nsk"),
    4: .same(proto: "ovk"),
    5: .standard(proto: "from_amount"),
    6: .standard(proto: "shielded_spends"),
    7: .standard(proto: "shielded_receives"),
    8: .standard(proto: "transparent_to_address"),
    9: .standard(proto: "to_amount"),
    10: .same(proto: "timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transparentFromAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ask) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nsk) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.ovk) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.fromAmount) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.shieldedSpends) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.shieldedReceives) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.transparentToAddress) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.toAmount) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transparentFromAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transparentFromAddress, fieldNumber: 1)
    }
    if !self.ask.isEmpty {
      try visitor.visitSingularBytesField(value: self.ask, fieldNumber: 2)
    }
    if !self.nsk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nsk, fieldNumber: 3)
    }
    if !self.ovk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovk, fieldNumber: 4)
    }
    if self.fromAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.fromAmount, fieldNumber: 5)
    }
    if !self.shieldedSpends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shieldedSpends, fieldNumber: 6)
    }
    if !self.shieldedReceives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shieldedReceives, fieldNumber: 7)
    }
    if !self.transparentToAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transparentToAddress, fieldNumber: 8)
    }
    if self.toAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.toAmount, fieldNumber: 9)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt64Field(value: self.timeout, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PrivateParameters, rhs: Protocol_PrivateParameters) -> Bool {
    if lhs.transparentFromAddress != rhs.transparentFromAddress {return false}
    if lhs.ask != rhs.ask {return false}
    if lhs.nsk != rhs.nsk {return false}
    if lhs.ovk != rhs.ovk {return false}
    if lhs.fromAmount != rhs.fromAmount {return false}
    if lhs.shieldedSpends != rhs.shieldedSpends {return false}
    if lhs.shieldedReceives != rhs.shieldedReceives {return false}
    if lhs.transparentToAddress != rhs.transparentToAddress {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PrivateParametersWithoutAsk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivateParametersWithoutAsk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transparent_from_address"),
    2: .same(proto: "ak"),
    3: .same(proto: "nsk"),
    4: .same(proto: "ovk"),
    5: .standard(proto: "from_amount"),
    6: .standard(proto: "shielded_spends"),
    7: .standard(proto: "shielded_receives"),
    8: .standard(proto: "transparent_to_address"),
    9: .standard(proto: "to_amount"),
    10: .same(proto: "timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transparentFromAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nsk) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.ovk) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.fromAmount) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.shieldedSpends) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.shieldedReceives) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.transparentToAddress) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.toAmount) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transparentFromAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transparentFromAddress, fieldNumber: 1)
    }
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 2)
    }
    if !self.nsk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nsk, fieldNumber: 3)
    }
    if !self.ovk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovk, fieldNumber: 4)
    }
    if self.fromAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.fromAmount, fieldNumber: 5)
    }
    if !self.shieldedSpends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shieldedSpends, fieldNumber: 6)
    }
    if !self.shieldedReceives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shieldedReceives, fieldNumber: 7)
    }
    if !self.transparentToAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transparentToAddress, fieldNumber: 8)
    }
    if self.toAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.toAmount, fieldNumber: 9)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt64Field(value: self.timeout, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PrivateParametersWithoutAsk, rhs: Protocol_PrivateParametersWithoutAsk) -> Bool {
    if lhs.transparentFromAddress != rhs.transparentFromAddress {return false}
    if lhs.ak != rhs.ak {return false}
    if lhs.nsk != rhs.nsk {return false}
    if lhs.ovk != rhs.ovk {return false}
    if lhs.fromAmount != rhs.fromAmount {return false}
    if lhs.shieldedSpends != rhs.shieldedSpends {return false}
    if lhs.shieldedReceives != rhs.shieldedReceives {return false}
    if lhs.transparentToAddress != rhs.transparentToAddress {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SpendAuthSigParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendAuthSigParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ask"),
    2: .standard(proto: "tx_hash"),
    3: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ask) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ask.isEmpty {
      try visitor.visitSingularBytesField(value: self.ask, fieldNumber: 1)
    }
    if !self.txHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHash, fieldNumber: 2)
    }
    if !self.alpha.isEmpty {
      try visitor.visitSingularBytesField(value: self.alpha, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_SpendAuthSigParameters, rhs: Protocol_SpendAuthSigParameters) -> Bool {
    if lhs.ask != rhs.ask {return false}
    if lhs.txHash != rhs.txHash {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NfParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NfParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    2: .same(proto: "voucher"),
    3: .same(proto: "ak"),
    4: .same(proto: "nk"),
  ]

  fileprivate class _StorageClass {
    var _note: Protocol_Note? = nil
    var _voucher: Protocol_IncrementalMerkleVoucher? = nil
    var _ak: Data = Data()
    var _nk: Data = Data()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _note = source._note
      _voucher = source._voucher
      _ak = source._ak
      _nk = source._nk
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._note) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._voucher) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._ak) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._nk) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._note {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._voucher {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._ak.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._ak, fieldNumber: 3)
      }
      if !_storage._nk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nk, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NfParameters, rhs: Protocol_NfParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._note != rhs_storage._note {return false}
        if _storage._voucher != rhs_storage._voucher {return false}
        if _storage._ak != rhs_storage._ak {return false}
        if _storage._nk != rhs_storage._nk {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ExpandedSpendingKeyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExpandedSpendingKeyMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ask"),
    2: .same(proto: "nsk"),
    3: .same(proto: "ovk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ask) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nsk) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ovk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ask.isEmpty {
      try visitor.visitSingularBytesField(value: self.ask, fieldNumber: 1)
    }
    if !self.nsk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nsk, fieldNumber: 2)
    }
    if !self.ovk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovk, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ExpandedSpendingKeyMessage, rhs: Protocol_ExpandedSpendingKeyMessage) -> Bool {
    if lhs.ask != rhs.ask {return false}
    if lhs.nsk != rhs.nsk {return false}
    if lhs.ovk != rhs.ovk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ViewingKeyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ViewingKeyMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ak"),
    2: .same(proto: "nk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 1)
    }
    if !self.nk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nk, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ViewingKeyMessage, rhs: Protocol_ViewingKeyMessage) -> Bool {
    if lhs.ak != rhs.ak {return false}
    if lhs.nk != rhs.nk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_IncomingViewingKeyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingViewingKeyMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ivk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ivk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ivk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ivk, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_IncomingViewingKeyMessage, rhs: Protocol_IncomingViewingKeyMessage) -> Bool {
    if lhs.ivk != rhs.ivk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DiversifierMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiversifierMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "d"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.d) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.d.isEmpty {
      try visitor.visitSingularBytesField(value: self.d, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DiversifierMessage, rhs: Protocol_DiversifierMessage) -> Bool {
    if lhs.d != rhs.d {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_IncomingViewingKeyDiversifierMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingViewingKeyDiversifierMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ivk"),
    2: .same(proto: "d"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ivk) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._d) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ivk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._d {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_IncomingViewingKeyDiversifierMessage, rhs: Protocol_IncomingViewingKeyDiversifierMessage) -> Bool {
    if lhs._ivk != rhs._ivk {return false}
    if lhs._d != rhs._d {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PaymentAddressMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentAddressMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "d"),
    2: .same(proto: "pkD"),
    3: .standard(proto: "payment_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._d) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pkD) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.paymentAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._d {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pkD.isEmpty {
      try visitor.visitSingularBytesField(value: self.pkD, fieldNumber: 2)
    }
    if !self.paymentAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PaymentAddressMessage, rhs: Protocol_PaymentAddressMessage) -> Bool {
    if lhs._d != rhs._d {return false}
    if lhs.pkD != rhs.pkD {return false}
    if lhs.paymentAddress != rhs.paymentAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ShieldedAddressInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShieldedAddressInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sk"),
    2: .same(proto: "ask"),
    3: .same(proto: "nsk"),
    4: .same(proto: "ovk"),
    5: .same(proto: "ak"),
    6: .same(proto: "nk"),
    7: .same(proto: "ivk"),
    8: .same(proto: "d"),
    9: .same(proto: "pkD"),
    10: .standard(proto: "payment_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sk) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ask) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nsk) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.ovk) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.nk) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.ivk) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.d) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.pkD) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.paymentAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sk.isEmpty {
      try visitor.visitSingularBytesField(value: self.sk, fieldNumber: 1)
    }
    if !self.ask.isEmpty {
      try visitor.visitSingularBytesField(value: self.ask, fieldNumber: 2)
    }
    if !self.nsk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nsk, fieldNumber: 3)
    }
    if !self.ovk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovk, fieldNumber: 4)
    }
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 5)
    }
    if !self.nk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nk, fieldNumber: 6)
    }
    if !self.ivk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ivk, fieldNumber: 7)
    }
    if !self.d.isEmpty {
      try visitor.visitSingularBytesField(value: self.d, fieldNumber: 8)
    }
    if !self.pkD.isEmpty {
      try visitor.visitSingularBytesField(value: self.pkD, fieldNumber: 9)
    }
    if !self.paymentAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentAddress, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ShieldedAddressInfo, rhs: Protocol_ShieldedAddressInfo) -> Bool {
    if lhs.sk != rhs.sk {return false}
    if lhs.ask != rhs.ask {return false}
    if lhs.nsk != rhs.nsk {return false}
    if lhs.ovk != rhs.ovk {return false}
    if lhs.ak != rhs.ak {return false}
    if lhs.nk != rhs.nk {return false}
    if lhs.ivk != rhs.ivk {return false}
    if lhs.d != rhs.d {return false}
    if lhs.pkD != rhs.pkD {return false}
    if lhs.paymentAddress != rhs.paymentAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NoteParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoteParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ak"),
    2: .same(proto: "nk"),
    3: .same(proto: "note"),
    4: .same(proto: "txid"),
    5: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nk) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 1)
    }
    if !self.nk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nk, fieldNumber: 2)
    }
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 4)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NoteParameters, rhs: Protocol_NoteParameters) -> Bool {
    if lhs.ak != rhs.ak {return false}
    if lhs.nk != rhs.nk {return false}
    if lhs._note != rhs._note {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SpendResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_SpendResult, rhs: Protocol_SpendResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionInfoList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionInfoList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactionInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactionInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionInfoList, rhs: Protocol_TransactionInfoList) -> Bool {
    if lhs.transactionInfo != rhs.transactionInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SpendNoteTRC20: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendNoteTRC20"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    2: .same(proto: "alpha"),
    3: .same(proto: "root"),
    4: .same(proto: "path"),
    5: .same(proto: "pos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.alpha) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.root) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.path) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.pos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.alpha.isEmpty {
      try visitor.visitSingularBytesField(value: self.alpha, fieldNumber: 2)
    }
    if !self.root.isEmpty {
      try visitor.visitSingularBytesField(value: self.root, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularBytesField(value: self.path, fieldNumber: 4)
    }
    if self.pos != 0 {
      try visitor.visitSingularInt64Field(value: self.pos, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_SpendNoteTRC20, rhs: Protocol_SpendNoteTRC20) -> Bool {
    if lhs._note != rhs._note {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.root != rhs.root {return false}
    if lhs.path != rhs.path {return false}
    if lhs.pos != rhs.pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PrivateShieldedTRC20Parameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivateShieldedTRC20Parameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ask"),
    2: .same(proto: "nsk"),
    3: .same(proto: "ovk"),
    4: .standard(proto: "from_amount"),
    5: .standard(proto: "shielded_spends"),
    6: .standard(proto: "shielded_receives"),
    7: .standard(proto: "transparent_to_address"),
    8: .standard(proto: "to_amount"),
    9: .standard(proto: "shielded_TRC20_contract_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ask) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nsk) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ovk) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fromAmount) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.shieldedSpends) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.shieldedReceives) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.transparentToAddress) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.toAmount) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.shieldedTrc20ContractAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ask.isEmpty {
      try visitor.visitSingularBytesField(value: self.ask, fieldNumber: 1)
    }
    if !self.nsk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nsk, fieldNumber: 2)
    }
    if !self.ovk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovk, fieldNumber: 3)
    }
    if !self.fromAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.fromAmount, fieldNumber: 4)
    }
    if !self.shieldedSpends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shieldedSpends, fieldNumber: 5)
    }
    if !self.shieldedReceives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shieldedReceives, fieldNumber: 6)
    }
    if !self.transparentToAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transparentToAddress, fieldNumber: 7)
    }
    if !self.toAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.toAmount, fieldNumber: 8)
    }
    if !self.shieldedTrc20ContractAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.shieldedTrc20ContractAddress, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PrivateShieldedTRC20Parameters, rhs: Protocol_PrivateShieldedTRC20Parameters) -> Bool {
    if lhs.ask != rhs.ask {return false}
    if lhs.nsk != rhs.nsk {return false}
    if lhs.ovk != rhs.ovk {return false}
    if lhs.fromAmount != rhs.fromAmount {return false}
    if lhs.shieldedSpends != rhs.shieldedSpends {return false}
    if lhs.shieldedReceives != rhs.shieldedReceives {return false}
    if lhs.transparentToAddress != rhs.transparentToAddress {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.shieldedTrc20ContractAddress != rhs.shieldedTrc20ContractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PrivateShieldedTRC20ParametersWithoutAsk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivateShieldedTRC20ParametersWithoutAsk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ak"),
    2: .same(proto: "nsk"),
    3: .same(proto: "ovk"),
    4: .standard(proto: "from_amount"),
    5: .standard(proto: "shielded_spends"),
    6: .standard(proto: "shielded_receives"),
    7: .standard(proto: "transparent_to_address"),
    8: .standard(proto: "to_amount"),
    9: .standard(proto: "shielded_TRC20_contract_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nsk) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ovk) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fromAmount) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.shieldedSpends) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.shieldedReceives) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.transparentToAddress) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.toAmount) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.shieldedTrc20ContractAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 1)
    }
    if !self.nsk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nsk, fieldNumber: 2)
    }
    if !self.ovk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovk, fieldNumber: 3)
    }
    if !self.fromAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.fromAmount, fieldNumber: 4)
    }
    if !self.shieldedSpends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shieldedSpends, fieldNumber: 5)
    }
    if !self.shieldedReceives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shieldedReceives, fieldNumber: 6)
    }
    if !self.transparentToAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transparentToAddress, fieldNumber: 7)
    }
    if !self.toAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.toAmount, fieldNumber: 8)
    }
    if !self.shieldedTrc20ContractAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.shieldedTrc20ContractAddress, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PrivateShieldedTRC20ParametersWithoutAsk, rhs: Protocol_PrivateShieldedTRC20ParametersWithoutAsk) -> Bool {
    if lhs.ak != rhs.ak {return false}
    if lhs.nsk != rhs.nsk {return false}
    if lhs.ovk != rhs.ovk {return false}
    if lhs.fromAmount != rhs.fromAmount {return false}
    if lhs.shieldedSpends != rhs.shieldedSpends {return false}
    if lhs.shieldedReceives != rhs.shieldedReceives {return false}
    if lhs.transparentToAddress != rhs.transparentToAddress {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.shieldedTrc20ContractAddress != rhs.shieldedTrc20ContractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ShieldedTRC20Parameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShieldedTRC20Parameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spend_description"),
    2: .standard(proto: "receive_description"),
    3: .standard(proto: "binding_signature"),
    4: .standard(proto: "message_hash"),
    5: .standard(proto: "trigger_contract_input"),
    6: .standard(proto: "parameter_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.spendDescription) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.receiveDescription) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.bindingSignature) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.messageHash) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.triggerContractInput) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.parameterType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spendDescription.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spendDescription, fieldNumber: 1)
    }
    if !self.receiveDescription.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receiveDescription, fieldNumber: 2)
    }
    if !self.bindingSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.bindingSignature, fieldNumber: 3)
    }
    if !self.messageHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageHash, fieldNumber: 4)
    }
    if !self.triggerContractInput.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerContractInput, fieldNumber: 5)
    }
    if !self.parameterType.isEmpty {
      try visitor.visitSingularStringField(value: self.parameterType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ShieldedTRC20Parameters, rhs: Protocol_ShieldedTRC20Parameters) -> Bool {
    if lhs.spendDescription != rhs.spendDescription {return false}
    if lhs.receiveDescription != rhs.receiveDescription {return false}
    if lhs.bindingSignature != rhs.bindingSignature {return false}
    if lhs.messageHash != rhs.messageHash {return false}
    if lhs.triggerContractInput != rhs.triggerContractInput {return false}
    if lhs.parameterType != rhs.parameterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_IvkDecryptTRC20Parameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IvkDecryptTRC20Parameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_block_index"),
    2: .standard(proto: "end_block_index"),
    3: .standard(proto: "shielded_TRC20_contract_address"),
    4: .same(proto: "ivk"),
    5: .same(proto: "ak"),
    6: .same(proto: "nk"),
    7: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startBlockIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endBlockIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.shieldedTrc20ContractAddress) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.ivk) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.nk) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.startBlockIndex, fieldNumber: 1)
    }
    if self.endBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.endBlockIndex, fieldNumber: 2)
    }
    if !self.shieldedTrc20ContractAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.shieldedTrc20ContractAddress, fieldNumber: 3)
    }
    if !self.ivk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ivk, fieldNumber: 4)
    }
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 5)
    }
    if !self.nk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nk, fieldNumber: 6)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedStringField(value: self.events, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_IvkDecryptTRC20Parameters, rhs: Protocol_IvkDecryptTRC20Parameters) -> Bool {
    if lhs.startBlockIndex != rhs.startBlockIndex {return false}
    if lhs.endBlockIndex != rhs.endBlockIndex {return false}
    if lhs.shieldedTrc20ContractAddress != rhs.shieldedTrc20ContractAddress {return false}
    if lhs.ivk != rhs.ivk {return false}
    if lhs.ak != rhs.ak {return false}
    if lhs.nk != rhs.nk {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_OvkDecryptTRC20Parameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OvkDecryptTRC20Parameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_block_index"),
    2: .standard(proto: "end_block_index"),
    3: .same(proto: "ovk"),
    4: .standard(proto: "shielded_TRC20_contract_address"),
    5: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startBlockIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endBlockIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ovk) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.shieldedTrc20ContractAddress) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.startBlockIndex, fieldNumber: 1)
    }
    if self.endBlockIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.endBlockIndex, fieldNumber: 2)
    }
    if !self.ovk.isEmpty {
      try visitor.visitSingularBytesField(value: self.ovk, fieldNumber: 3)
    }
    if !self.shieldedTrc20ContractAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.shieldedTrc20ContractAddress, fieldNumber: 4)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedStringField(value: self.events, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_OvkDecryptTRC20Parameters, rhs: Protocol_OvkDecryptTRC20Parameters) -> Bool {
    if lhs.startBlockIndex != rhs.startBlockIndex {return false}
    if lhs.endBlockIndex != rhs.endBlockIndex {return false}
    if lhs.ovk != rhs.ovk {return false}
    if lhs.shieldedTrc20ContractAddress != rhs.shieldedTrc20ContractAddress {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DecryptNotesTRC20: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptNotesTRC20"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "noteTxs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.noteTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.noteTxs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noteTxs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DecryptNotesTRC20, rhs: Protocol_DecryptNotesTRC20) -> Bool {
    if lhs.noteTxs != rhs.noteTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DecryptNotesTRC20.NoteTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_DecryptNotesTRC20.protoMessageName + ".NoteTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    2: .same(proto: "position"),
    3: .standard(proto: "is_spent"),
    4: .same(proto: "txid"),
    5: .same(proto: "index"),
    6: .standard(proto: "to_amount"),
    7: .standard(proto: "transparent_to_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.position) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isSpent) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.toAmount) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.transparentToAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.position != 0 {
      try visitor.visitSingularInt64Field(value: self.position, fieldNumber: 2)
    }
    if self.isSpent != false {
      try visitor.visitSingularBoolField(value: self.isSpent, fieldNumber: 3)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 4)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 5)
    }
    if !self.toAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.toAmount, fieldNumber: 6)
    }
    if !self.transparentToAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transparentToAddress, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DecryptNotesTRC20.NoteTx, rhs: Protocol_DecryptNotesTRC20.NoteTx) -> Bool {
    if lhs._note != rhs._note {return false}
    if lhs.position != rhs.position {return false}
    if lhs.isSpent != rhs.isSpent {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.index != rhs.index {return false}
    if lhs.toAmount != rhs.toAmount {return false}
    if lhs.transparentToAddress != rhs.transparentToAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NfTRC20Parameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NfTRC20Parameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "note"),
    2: .same(proto: "ak"),
    3: .same(proto: "nk"),
    4: .same(proto: "position"),
    5: .standard(proto: "shielded_TRC20_contract_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ak) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nk) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.position) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.shieldedTrc20ContractAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ak.isEmpty {
      try visitor.visitSingularBytesField(value: self.ak, fieldNumber: 2)
    }
    if !self.nk.isEmpty {
      try visitor.visitSingularBytesField(value: self.nk, fieldNumber: 3)
    }
    if self.position != 0 {
      try visitor.visitSingularInt64Field(value: self.position, fieldNumber: 4)
    }
    if !self.shieldedTrc20ContractAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.shieldedTrc20ContractAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NfTRC20Parameters, rhs: Protocol_NfTRC20Parameters) -> Bool {
    if lhs._note != rhs._note {return false}
    if lhs.ak != rhs.ak {return false}
    if lhs.nk != rhs.nk {return false}
    if lhs.position != rhs.position {return false}
    if lhs.shieldedTrc20ContractAddress != rhs.shieldedTrc20ContractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NullifierResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NullifierResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_spent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isSpent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isSpent != false {
      try visitor.visitSingularBoolField(value: self.isSpent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NullifierResult, rhs: Protocol_NullifierResult) -> Bool {
    if lhs.isSpent != rhs.isSpent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ShieldedTRC20TriggerContractParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShieldedTRC20TriggerContractParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shielded_TRC20_Parameters"),
    2: .standard(proto: "spend_authority_signature"),
    3: .same(proto: "amount"),
    4: .standard(proto: "transparent_to_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shieldedTrc20Parameters) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spendAuthoritySignature) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.transparentToAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shieldedTrc20Parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.spendAuthoritySignature.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spendAuthoritySignature, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 3)
    }
    if !self.transparentToAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transparentToAddress, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ShieldedTRC20TriggerContractParameters, rhs: Protocol_ShieldedTRC20TriggerContractParameters) -> Bool {
    if lhs._shieldedTrc20Parameters != rhs._shieldedTrc20Parameters {return false}
    if lhs.spendAuthoritySignature != rhs.spendAuthoritySignature {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.transparentToAddress != rhs.transparentToAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
