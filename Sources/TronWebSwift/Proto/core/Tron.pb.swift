// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core/Tron.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Protocol_AccountType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case normal // = 0
  case assetIssue // = 1
  case contract // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .normal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .assetIssue
    case 2: self = .contract
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .normal: return 0
    case .assetIssue: return 1
    case .contract: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_AccountType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_AccountType] = [
    .normal,
    .assetIssue,
    .contract,
  ]
}

#endif  // swift(>=4.2)

public enum Protocol_ReasonCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case requested // = 0
  case badProtocol // = 2
  case tooManyPeers // = 4
  case duplicatePeer // = 5
  case incompatibleProtocol // = 6
  case randomElimination // = 7
  case peerQuiting // = 8
  case unexpectedIdentity // = 9
  case localIdentity // = 10
  case pingTimeout // = 11
  case userReason // = 16
  case reset // = 17
  case syncFail // = 18
  case fetchFail // = 19
  case badTx // = 20
  case badBlock // = 21
  case forked // = 22
  case unlinkable // = 23
  case incompatibleVersion // = 24
  case incompatibleChain // = 25
  case timeOut // = 32
  case connectFail // = 33
  case tooManyPeersWithSameIp // = 34
  case lightNodeSyncFail // = 35
  case unknown // = 255
  case UNRECOGNIZED(Int)

  public init() {
    self = .requested
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .requested
    case 2: self = .badProtocol
    case 4: self = .tooManyPeers
    case 5: self = .duplicatePeer
    case 6: self = .incompatibleProtocol
    case 7: self = .randomElimination
    case 8: self = .peerQuiting
    case 9: self = .unexpectedIdentity
    case 10: self = .localIdentity
    case 11: self = .pingTimeout
    case 16: self = .userReason
    case 17: self = .reset
    case 18: self = .syncFail
    case 19: self = .fetchFail
    case 20: self = .badTx
    case 21: self = .badBlock
    case 22: self = .forked
    case 23: self = .unlinkable
    case 24: self = .incompatibleVersion
    case 25: self = .incompatibleChain
    case 32: self = .timeOut
    case 33: self = .connectFail
    case 34: self = .tooManyPeersWithSameIp
    case 35: self = .lightNodeSyncFail
    case 255: self = .unknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .requested: return 0
    case .badProtocol: return 2
    case .tooManyPeers: return 4
    case .duplicatePeer: return 5
    case .incompatibleProtocol: return 6
    case .randomElimination: return 7
    case .peerQuiting: return 8
    case .unexpectedIdentity: return 9
    case .localIdentity: return 10
    case .pingTimeout: return 11
    case .userReason: return 16
    case .reset: return 17
    case .syncFail: return 18
    case .fetchFail: return 19
    case .badTx: return 20
    case .badBlock: return 21
    case .forked: return 22
    case .unlinkable: return 23
    case .incompatibleVersion: return 24
    case .incompatibleChain: return 25
    case .timeOut: return 32
    case .connectFail: return 33
    case .tooManyPeersWithSameIp: return 34
    case .lightNodeSyncFail: return 35
    case .unknown: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_ReasonCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_ReasonCode] = [
    .requested,
    .badProtocol,
    .tooManyPeers,
    .duplicatePeer,
    .incompatibleProtocol,
    .randomElimination,
    .peerQuiting,
    .unexpectedIdentity,
    .localIdentity,
    .pingTimeout,
    .userReason,
    .reset,
    .syncFail,
    .fetchFail,
    .badTx,
    .badBlock,
    .forked,
    .unlinkable,
    .incompatibleVersion,
    .incompatibleChain,
    .timeOut,
    .connectFail,
    .tooManyPeersWithSameIp,
    .lightNodeSyncFail,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

/// AccountId, (name, address) use name, (null, address) use address, (name, null) use name,
public struct Protocol_AccountId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Data = Data()

  public var address: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// vote message
public struct Protocol_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the super rep address
  public var voteAddress: Data = Data()

  /// the vote num to this super rep.
  public var voteCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Proposal
public struct Protocol_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var proposalID: Int64 = 0

  public var proposerAddress: Data = Data()

  public var parameters: Dictionary<Int64,Int64> = [:]

  public var expirationTime: Int64 = 0

  public var createTime: Int64 = 0

  public var approvals: [Data] = []

  public var state: Protocol_Proposal.State = .pending

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case pending // = 0
    case disapproved // = 1
    case approved // = 2
    case canceled // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .pending
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .disapproved
      case 2: self = .approved
      case 3: self = .canceled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .pending: return 0
      case .disapproved: return 1
      case .approved: return 2
      case .canceled: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Proposal.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Proposal.State] = [
    .pending,
    .disapproved,
    .approved,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

/// Exchange
public struct Protocol_Exchange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: Int64 = 0

  public var creatorAddress: Data = Data()

  public var createTime: Int64 = 0

  public var firstTokenID: Data = Data()

  public var firstTokenBalance: Int64 = 0

  public var secondTokenID: Data = Data()

  public var secondTokenBalance: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// market
public struct Protocol_MarketOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var orderID: Data = Data()

  public var ownerAddress: Data = Data()

  public var createTime: Int64 = 0

  public var sellTokenID: Data = Data()

  public var sellTokenQuantity: Int64 = 0

  public var buyTokenID: Data = Data()

  /// min to receive
  public var buyTokenQuantity: Int64 = 0

  public var sellTokenQuantityRemain: Int64 = 0

  /// When state != ACTIVE and sell_token_quantity_return !=0,
  ///it means that some sell tokens are returned to the account due to insufficient remaining amount
  public var sellTokenQuantityReturn: Int64 = 0

  public var state: Protocol_MarketOrder.State = .active

  public var prev: Data = Data()

  public var next: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case active // = 0
    case inactive // = 1
    case canceled // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .active
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .active
      case 1: self = .inactive
      case 2: self = .canceled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .active: return 0
      case .inactive: return 1
      case .canceled: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_MarketOrder.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_MarketOrder.State] = [
    .active,
    .inactive,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_MarketOrderList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var orders: [Protocol_MarketOrder] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_MarketOrderPairList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var orderPair: [Protocol_MarketOrderPair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_MarketOrderPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sellTokenID: Data = Data()

  public var buyTokenID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_MarketAccountOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ownerAddress: Data = Data()

  /// order_id list
  public var orders: [Data] = []

  /// active count
  public var count: Int64 = 0

  public var totalCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_MarketPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sellTokenQuantity: Int64 = 0

  public var buyTokenQuantity: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_MarketPriceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sellTokenID: Data = Data()

  public var buyTokenID: Data = Data()

  public var prices: [Protocol_MarketPrice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_MarketOrderIdList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var head: Data = Data()

  public var tail: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ChainParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainParameter: [Protocol_ChainParameters.ChainParameter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ChainParameter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Account 
public struct Protocol_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account nick name
  public var accountName: Data {
    get {return _storage._accountName}
    set {_uniqueStorage()._accountName = newValue}
  }

  public var type: Protocol_AccountType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// the create address
  public var address: Data {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// the trx balance
  public var balance: Int64 {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  /// the votes
  public var votes: [Protocol_Vote] {
    get {return _storage._votes}
    set {_uniqueStorage()._votes = newValue}
  }

  /// the other asset owned by this account
  public var asset: Dictionary<String,Int64> {
    get {return _storage._asset}
    set {_uniqueStorage()._asset = newValue}
  }

  /// the other asset owned by this accountï¼Œkey is assetId
  public var assetV2: Dictionary<String,Int64> {
    get {return _storage._assetV2}
    set {_uniqueStorage()._assetV2 = newValue}
  }

  /// the frozen balance for bandwidth
  public var frozen: [Protocol_Account.Frozen] {
    get {return _storage._frozen}
    set {_uniqueStorage()._frozen = newValue}
  }

  /// bandwidth, get from frozen
  public var netUsage: Int64 {
    get {return _storage._netUsage}
    set {_uniqueStorage()._netUsage = newValue}
  }

  ///Frozen balance provided by other accounts to this account
  public var acquiredDelegatedFrozenBalanceForBandwidth: Int64 {
    get {return _storage._acquiredDelegatedFrozenBalanceForBandwidth}
    set {_uniqueStorage()._acquiredDelegatedFrozenBalanceForBandwidth = newValue}
  }

  ///Freeze and provide balances to other accounts
  public var delegatedFrozenBalanceForBandwidth: Int64 {
    get {return _storage._delegatedFrozenBalanceForBandwidth}
    set {_uniqueStorage()._delegatedFrozenBalanceForBandwidth = newValue}
  }

  public var oldTronPower: Int64 {
    get {return _storage._oldTronPower}
    set {_uniqueStorage()._oldTronPower = newValue}
  }

  public var tronPower: Protocol_Account.Frozen {
    get {return _storage._tronPower ?? Protocol_Account.Frozen()}
    set {_uniqueStorage()._tronPower = newValue}
  }
  /// Returns true if `tronPower` has been explicitly set.
  public var hasTronPower: Bool {return _storage._tronPower != nil}
  /// Clears the value of `tronPower`. Subsequent reads from it will return its default value.
  public mutating func clearTronPower() {_uniqueStorage()._tronPower = nil}

  public var assetOptimized: Bool {
    get {return _storage._assetOptimized}
    set {_uniqueStorage()._assetOptimized = newValue}
  }

  /// this account create time
  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// this last operation time, including transfer, voting and so on. //FIXME fix grammar
  public var latestOprationTime: Int64 {
    get {return _storage._latestOprationTime}
    set {_uniqueStorage()._latestOprationTime = newValue}
  }

  /// witness block producing allowance
  public var allowance: Int64 {
    get {return _storage._allowance}
    set {_uniqueStorage()._allowance = newValue}
  }

  /// last withdraw time
  public var latestWithdrawTime: Int64 {
    get {return _storage._latestWithdrawTime}
    set {_uniqueStorage()._latestWithdrawTime = newValue}
  }

  /// not used so far
  public var code: Data {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var isWitness: Bool {
    get {return _storage._isWitness}
    set {_uniqueStorage()._isWitness = newValue}
  }

  public var isCommittee: Bool {
    get {return _storage._isCommittee}
    set {_uniqueStorage()._isCommittee = newValue}
  }

  /// frozen asset(for asset issuer)
  public var frozenSupply: [Protocol_Account.Frozen] {
    get {return _storage._frozenSupply}
    set {_uniqueStorage()._frozenSupply = newValue}
  }

  /// asset_issued_name
  public var assetIssuedName: Data {
    get {return _storage._assetIssuedName}
    set {_uniqueStorage()._assetIssuedName = newValue}
  }

  public var assetIssuedID: Data {
    get {return _storage._assetIssuedID}
    set {_uniqueStorage()._assetIssuedID = newValue}
  }

  public var latestAssetOperationTime: Dictionary<String,Int64> {
    get {return _storage._latestAssetOperationTime}
    set {_uniqueStorage()._latestAssetOperationTime = newValue}
  }

  public var latestAssetOperationTimeV2: Dictionary<String,Int64> {
    get {return _storage._latestAssetOperationTimeV2}
    set {_uniqueStorage()._latestAssetOperationTimeV2 = newValue}
  }

  public var freeNetUsage: Int64 {
    get {return _storage._freeNetUsage}
    set {_uniqueStorage()._freeNetUsage = newValue}
  }

  public var freeAssetNetUsage: Dictionary<String,Int64> {
    get {return _storage._freeAssetNetUsage}
    set {_uniqueStorage()._freeAssetNetUsage = newValue}
  }

  public var freeAssetNetUsageV2: Dictionary<String,Int64> {
    get {return _storage._freeAssetNetUsageV2}
    set {_uniqueStorage()._freeAssetNetUsageV2 = newValue}
  }

  public var latestConsumeTime: Int64 {
    get {return _storage._latestConsumeTime}
    set {_uniqueStorage()._latestConsumeTime = newValue}
  }

  public var latestConsumeFreeTime: Int64 {
    get {return _storage._latestConsumeFreeTime}
    set {_uniqueStorage()._latestConsumeFreeTime = newValue}
  }

  /// the identity of this account, case insensitive
  public var accountID: Data {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  public var netWindowSize: Int64 {
    get {return _storage._netWindowSize}
    set {_uniqueStorage()._netWindowSize = newValue}
  }

  public var accountResource: Protocol_Account.AccountResource {
    get {return _storage._accountResource ?? Protocol_Account.AccountResource()}
    set {_uniqueStorage()._accountResource = newValue}
  }
  /// Returns true if `accountResource` has been explicitly set.
  public var hasAccountResource: Bool {return _storage._accountResource != nil}
  /// Clears the value of `accountResource`. Subsequent reads from it will return its default value.
  public mutating func clearAccountResource() {_uniqueStorage()._accountResource = nil}

  public var codeHash: Data {
    get {return _storage._codeHash}
    set {_uniqueStorage()._codeHash = newValue}
  }

  public var ownerPermission: Protocol_Permission {
    get {return _storage._ownerPermission ?? Protocol_Permission()}
    set {_uniqueStorage()._ownerPermission = newValue}
  }
  /// Returns true if `ownerPermission` has been explicitly set.
  public var hasOwnerPermission: Bool {return _storage._ownerPermission != nil}
  /// Clears the value of `ownerPermission`. Subsequent reads from it will return its default value.
  public mutating func clearOwnerPermission() {_uniqueStorage()._ownerPermission = nil}

  public var witnessPermission: Protocol_Permission {
    get {return _storage._witnessPermission ?? Protocol_Permission()}
    set {_uniqueStorage()._witnessPermission = newValue}
  }
  /// Returns true if `witnessPermission` has been explicitly set.
  public var hasWitnessPermission: Bool {return _storage._witnessPermission != nil}
  /// Clears the value of `witnessPermission`. Subsequent reads from it will return its default value.
  public mutating func clearWitnessPermission() {_uniqueStorage()._witnessPermission = nil}

  public var activePermission: [Protocol_Permission] {
    get {return _storage._activePermission}
    set {_uniqueStorage()._activePermission = newValue}
  }

  public var frozenV2: [Protocol_Account.FreezeV2] {
    get {return _storage._frozenV2}
    set {_uniqueStorage()._frozenV2 = newValue}
  }

  public var unfrozenV2: [Protocol_Account.UnFreezeV2] {
    get {return _storage._unfrozenV2}
    set {_uniqueStorage()._unfrozenV2 = newValue}
  }

  public var delegatedFrozenV2BalanceForBandwidth: Int64 {
    get {return _storage._delegatedFrozenV2BalanceForBandwidth}
    set {_uniqueStorage()._delegatedFrozenV2BalanceForBandwidth = newValue}
  }

  public var acquiredDelegatedFrozenV2BalanceForBandwidth: Int64 {
    get {return _storage._acquiredDelegatedFrozenV2BalanceForBandwidth}
    set {_uniqueStorage()._acquiredDelegatedFrozenV2BalanceForBandwidth = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// frozen balance 
  public struct Frozen {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the frozen trx balance
    public var frozenBalance: Int64 = 0

    /// the expire time
    public var expireTime: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct AccountResource {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// energy resource, get from frozen
    public var energyUsage: Int64 = 0

    /// the frozen balance for energy
    public var frozenBalanceForEnergy: Protocol_Account.Frozen {
      get {return _frozenBalanceForEnergy ?? Protocol_Account.Frozen()}
      set {_frozenBalanceForEnergy = newValue}
    }
    /// Returns true if `frozenBalanceForEnergy` has been explicitly set.
    public var hasFrozenBalanceForEnergy: Bool {return self._frozenBalanceForEnergy != nil}
    /// Clears the value of `frozenBalanceForEnergy`. Subsequent reads from it will return its default value.
    public mutating func clearFrozenBalanceForEnergy() {self._frozenBalanceForEnergy = nil}

    public var latestConsumeTimeForEnergy: Int64 = 0

    ///Frozen balance provided by other accounts to this account
    public var acquiredDelegatedFrozenBalanceForEnergy: Int64 = 0

    ///Frozen balances provided to other accounts
    public var delegatedFrozenBalanceForEnergy: Int64 = 0

    /// storage resource, get from market
    public var storageLimit: Int64 = 0

    public var storageUsage: Int64 = 0

    public var latestExchangeStorageTime: Int64 = 0

    public var energyWindowSize: Int64 = 0

    public var delegatedFrozenV2BalanceForEnergy: Int64 = 0

    public var acquiredDelegatedFrozenV2BalanceForEnergy: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _frozenBalanceForEnergy: Protocol_Account.Frozen? = nil
  }

  public struct FreezeV2 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Protocol_ResourceCode = .bandwidth

    public var amount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct UnFreezeV2 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Protocol_ResourceCode = .bandwidth

    public var unfreezeAmount: Int64 = 0

    public var unfreezeExpireTime: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protocol_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Data = Data()

  public var weight: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DelegatedResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: Data = Data()

  public var to: Data = Data()

  public var frozenBalanceForBandwidth: Int64 = 0

  public var frozenBalanceForEnergy: Int64 = 0

  public var expireTimeForBandwidth: Int64 = 0

  public var expireTimeForEnergy: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_authority {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Protocol_AccountId {
    get {return _account ?? Protocol_AccountId()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  public var permissionName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Protocol_AccountId? = nil
}

public struct Protocol_Permission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Protocol_Permission.PermissionType = .owner

  ///Owner id=0, Witness id=1, Active id start by 2
  public var id: Int32 = 0

  public var permissionName: String = String()

  public var threshold: Int64 = 0

  public var parentID: Int32 = 0

  ///1 bit 1 contract
  public var operations: Data = Data()

  public var keys: [Protocol_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PermissionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case owner // = 0
    case witness // = 1
    case active // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .owner
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .owner
      case 1: self = .witness
      case 2: self = .active
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .owner: return 0
      case .witness: return 1
      case .active: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Permission.PermissionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Permission.PermissionType] = [
    .owner,
    .witness,
    .active,
  ]
}

#endif  // swift(>=4.2)

/// Witness
public struct Protocol_Witness {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Data = Data()

  public var voteCount: Int64 = 0

  public var pubKey: Data = Data()

  public var url: String = String()

  public var totalProduced: Int64 = 0

  public var totalMissed: Int64 = 0

  public var latestBlockNum: Int64 = 0

  public var latestSlotNum: Int64 = 0

  public var isJobs: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Vote Change
public struct Protocol_Votes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Data = Data()

  public var oldVotes: [Protocol_Vote] = []

  public var newVotes: [Protocol_Vote] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TXOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Int64 = 0

  public var pubKeyHash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TXInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: Protocol_TXInput.raw {
    get {return _rawData ?? Protocol_TXInput.raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {self._rawData = nil}

  public var signature: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var txID: Data = Data()

    public var vout: Int64 = 0

    public var pubKey: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _rawData: Protocol_TXInput.raw? = nil
}

public struct Protocol_TXOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var outputs: [Protocol_TXOutput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ResourceReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var energyUsage: Int64 = 0

  public var energyFee: Int64 = 0

  public var originEnergyUsage: Int64 = 0

  public var energyUsageTotal: Int64 = 0

  public var netUsage: Int64 = 0

  public var netFee: Int64 = 0

  public var result: Protocol_Transaction.Result.contractResult = .default

  public var energyPenaltyTotal: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_MarketOrderDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var makerOrderID: Data = Data()

  public var takerOrderID: Data = Data()

  public var fillSellQuantity: Int64 = 0

  public var fillBuyQuantity: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: Protocol_Transaction.raw {
    get {return _rawData ?? Protocol_Transaction.raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {self._rawData = nil}

  /// only support size = 1,  repeated list here for muti-sig extension
  public var signature: [Data] = []

  public var ret: [Protocol_Transaction.Result] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Contract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Protocol_Transaction.Contract.ContractType = .accountCreateContract

    public var parameter: SwiftProtobuf.Google_Protobuf_Any {
      get {return _parameter ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_parameter = newValue}
    }
    /// Returns true if `parameter` has been explicitly set.
    public var hasParameter: Bool {return self._parameter != nil}
    /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
    public mutating func clearParameter() {self._parameter = nil}

    public var provider: Data = Data()

    public var contractName: Data = Data()

    public var permissionID: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ContractType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case accountCreateContract // = 0
      case transferContract // = 1
      case transferAssetContract // = 2
      case voteAssetContract // = 3
      case voteWitnessContract // = 4
      case witnessCreateContract // = 5
      case assetIssueContract // = 6
      case witnessUpdateContract // = 8
      case participateAssetIssueContract // = 9
      case accountUpdateContract // = 10
      case freezeBalanceContract // = 11
      case unfreezeBalanceContract // = 12
      case withdrawBalanceContract // = 13
      case unfreezeAssetContract // = 14
      case updateAssetContract // = 15
      case proposalCreateContract // = 16
      case proposalApproveContract // = 17
      case proposalDeleteContract // = 18
      case setAccountIDContract // = 19
      case customContract // = 20
      case createSmartContract // = 30
      case triggerSmartContract // = 31
      case getContract // = 32
      case updateSettingContract // = 33
      case exchangeCreateContract // = 41
      case exchangeInjectContract // = 42
      case exchangeWithdrawContract // = 43
      case exchangeTransactionContract // = 44
      case updateEnergyLimitContract // = 45
      case accountPermissionUpdateContract // = 46
      case clearAbicontract // = 48
      case updateBrokerageContract // = 49
      case shieldedTransferContract // = 51
      case marketSellAssetContract // = 52
      case marketCancelOrderContract // = 53
      case freezeBalanceV2Contract // = 54
      case unfreezeBalanceV2Contract // = 55
      case withdrawExpireUnfreezeContract // = 56
      case delegateResourceContract // = 57
      case unDelegateResourceContract // = 58
      case UNRECOGNIZED(Int)

      public init() {
        self = .accountCreateContract
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .accountCreateContract
        case 1: self = .transferContract
        case 2: self = .transferAssetContract
        case 3: self = .voteAssetContract
        case 4: self = .voteWitnessContract
        case 5: self = .witnessCreateContract
        case 6: self = .assetIssueContract
        case 8: self = .witnessUpdateContract
        case 9: self = .participateAssetIssueContract
        case 10: self = .accountUpdateContract
        case 11: self = .freezeBalanceContract
        case 12: self = .unfreezeBalanceContract
        case 13: self = .withdrawBalanceContract
        case 14: self = .unfreezeAssetContract
        case 15: self = .updateAssetContract
        case 16: self = .proposalCreateContract
        case 17: self = .proposalApproveContract
        case 18: self = .proposalDeleteContract
        case 19: self = .setAccountIDContract
        case 20: self = .customContract
        case 30: self = .createSmartContract
        case 31: self = .triggerSmartContract
        case 32: self = .getContract
        case 33: self = .updateSettingContract
        case 41: self = .exchangeCreateContract
        case 42: self = .exchangeInjectContract
        case 43: self = .exchangeWithdrawContract
        case 44: self = .exchangeTransactionContract
        case 45: self = .updateEnergyLimitContract
        case 46: self = .accountPermissionUpdateContract
        case 48: self = .clearAbicontract
        case 49: self = .updateBrokerageContract
        case 51: self = .shieldedTransferContract
        case 52: self = .marketSellAssetContract
        case 53: self = .marketCancelOrderContract
        case 54: self = .freezeBalanceV2Contract
        case 55: self = .unfreezeBalanceV2Contract
        case 56: self = .withdrawExpireUnfreezeContract
        case 57: self = .delegateResourceContract
        case 58: self = .unDelegateResourceContract
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .accountCreateContract: return 0
        case .transferContract: return 1
        case .transferAssetContract: return 2
        case .voteAssetContract: return 3
        case .voteWitnessContract: return 4
        case .witnessCreateContract: return 5
        case .assetIssueContract: return 6
        case .witnessUpdateContract: return 8
        case .participateAssetIssueContract: return 9
        case .accountUpdateContract: return 10
        case .freezeBalanceContract: return 11
        case .unfreezeBalanceContract: return 12
        case .withdrawBalanceContract: return 13
        case .unfreezeAssetContract: return 14
        case .updateAssetContract: return 15
        case .proposalCreateContract: return 16
        case .proposalApproveContract: return 17
        case .proposalDeleteContract: return 18
        case .setAccountIDContract: return 19
        case .customContract: return 20
        case .createSmartContract: return 30
        case .triggerSmartContract: return 31
        case .getContract: return 32
        case .updateSettingContract: return 33
        case .exchangeCreateContract: return 41
        case .exchangeInjectContract: return 42
        case .exchangeWithdrawContract: return 43
        case .exchangeTransactionContract: return 44
        case .updateEnergyLimitContract: return 45
        case .accountPermissionUpdateContract: return 46
        case .clearAbicontract: return 48
        case .updateBrokerageContract: return 49
        case .shieldedTransferContract: return 51
        case .marketSellAssetContract: return 52
        case .marketCancelOrderContract: return 53
        case .freezeBalanceV2Contract: return 54
        case .unfreezeBalanceV2Contract: return 55
        case .withdrawExpireUnfreezeContract: return 56
        case .delegateResourceContract: return 57
        case .unDelegateResourceContract: return 58
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _parameter: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  public struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fee: Int64 = 0

    public var ret: Protocol_Transaction.Result.code = .sucess

    public var contractRet: Protocol_Transaction.Result.contractResult = .default

    public var assetIssueID: String = String()

    public var withdrawAmount: Int64 = 0

    public var unfreezeAmount: Int64 = 0

    public var exchangeReceivedAmount: Int64 = 0

    public var exchangeInjectAnotherAmount: Int64 = 0

    public var exchangeWithdrawAnotherAmount: Int64 = 0

    public var exchangeID: Int64 = 0

    public var shieldedTransactionFee: Int64 = 0

    public var orderID: Data = Data()

    public var orderDetails: [Protocol_MarketOrderDetail] = []

    public var withdrawExpireAmount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum code: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case sucess // = 0
      case failed // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .sucess
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .sucess
        case 1: self = .failed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .sucess: return 0
        case .failed: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum contractResult: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case `default` // = 0
      case success // = 1
      case revert // = 2
      case badJumpDestination // = 3
      case outOfMemory // = 4
      case precompiledContract // = 5
      case stackTooSmall // = 6
      case stackTooLarge // = 7
      case illegalOperation // = 8
      case stackOverflow // = 9
      case outOfEnergy // = 10
      case outOfTime // = 11
      case jvmStackOverFlow // = 12
      case unknown // = 13
      case transferFailed // = 14
      case invalidCode // = 15
      case UNRECOGNIZED(Int)

      public init() {
        self = .default
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .success
        case 2: self = .revert
        case 3: self = .badJumpDestination
        case 4: self = .outOfMemory
        case 5: self = .precompiledContract
        case 6: self = .stackTooSmall
        case 7: self = .stackTooLarge
        case 8: self = .illegalOperation
        case 9: self = .stackOverflow
        case 10: self = .outOfEnergy
        case 11: self = .outOfTime
        case 12: self = .jvmStackOverFlow
        case 13: self = .unknown
        case 14: self = .transferFailed
        case 15: self = .invalidCode
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .default: return 0
        case .success: return 1
        case .revert: return 2
        case .badJumpDestination: return 3
        case .outOfMemory: return 4
        case .precompiledContract: return 5
        case .stackTooSmall: return 6
        case .stackTooLarge: return 7
        case .illegalOperation: return 8
        case .stackOverflow: return 9
        case .outOfEnergy: return 10
        case .outOfTime: return 11
        case .jvmStackOverFlow: return 12
        case .unknown: return 13
        case .transferFailed: return 14
        case .invalidCode: return 15
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var refBlockBytes: Data = Data()

    public var refBlockNum: Int64 = 0

    public var refBlockHash: Data = Data()

    public var expiration: Int64 = 0

    public var auths: [Protocol_authority] = []

    /// data not used
    public var data: Data = Data()

    ///only support size = 1,  repeated list here for extension
    public var contract: [Protocol_Transaction.Contract] = []

    /// scripts not used
    public var scripts: Data = Data()

    public var timestamp: Int64 = 0

    public var feeLimit: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _rawData: Protocol_Transaction.raw? = nil
}

#if swift(>=4.2)

extension Protocol_Transaction.Contract.ContractType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Transaction.Contract.ContractType] = [
    .accountCreateContract,
    .transferContract,
    .transferAssetContract,
    .voteAssetContract,
    .voteWitnessContract,
    .witnessCreateContract,
    .assetIssueContract,
    .witnessUpdateContract,
    .participateAssetIssueContract,
    .accountUpdateContract,
    .freezeBalanceContract,
    .unfreezeBalanceContract,
    .withdrawBalanceContract,
    .unfreezeAssetContract,
    .updateAssetContract,
    .proposalCreateContract,
    .proposalApproveContract,
    .proposalDeleteContract,
    .setAccountIDContract,
    .customContract,
    .createSmartContract,
    .triggerSmartContract,
    .getContract,
    .updateSettingContract,
    .exchangeCreateContract,
    .exchangeInjectContract,
    .exchangeWithdrawContract,
    .exchangeTransactionContract,
    .updateEnergyLimitContract,
    .accountPermissionUpdateContract,
    .clearAbicontract,
    .updateBrokerageContract,
    .shieldedTransferContract,
    .marketSellAssetContract,
    .marketCancelOrderContract,
    .freezeBalanceV2Contract,
    .unfreezeBalanceV2Contract,
    .withdrawExpireUnfreezeContract,
    .delegateResourceContract,
    .unDelegateResourceContract,
  ]
}

extension Protocol_Transaction.Result.code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Transaction.Result.code] = [
    .sucess,
    .failed,
  ]
}

extension Protocol_Transaction.Result.contractResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Transaction.Result.contractResult] = [
    .default,
    .success,
    .revert,
    .badJumpDestination,
    .outOfMemory,
    .precompiledContract,
    .stackTooSmall,
    .stackTooLarge,
    .illegalOperation,
    .stackOverflow,
    .outOfEnergy,
    .outOfTime,
    .jvmStackOverFlow,
    .unknown,
    .transferFailed,
    .invalidCode,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Data {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var fee: Int64 {
    get {return _storage._fee}
    set {_uniqueStorage()._fee = newValue}
  }

  public var blockNumber: Int64 {
    get {return _storage._blockNumber}
    set {_uniqueStorage()._blockNumber = newValue}
  }

  public var blockTimeStamp: Int64 {
    get {return _storage._blockTimeStamp}
    set {_uniqueStorage()._blockTimeStamp = newValue}
  }

  public var contractResult: [Data] {
    get {return _storage._contractResult}
    set {_uniqueStorage()._contractResult = newValue}
  }

  public var contractAddress: Data {
    get {return _storage._contractAddress}
    set {_uniqueStorage()._contractAddress = newValue}
  }

  public var receipt: Protocol_ResourceReceipt {
    get {return _storage._receipt ?? Protocol_ResourceReceipt()}
    set {_uniqueStorage()._receipt = newValue}
  }
  /// Returns true if `receipt` has been explicitly set.
  public var hasReceipt: Bool {return _storage._receipt != nil}
  /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
  public mutating func clearReceipt() {_uniqueStorage()._receipt = nil}

  public var log: [Protocol_TransactionInfo.Log] {
    get {return _storage._log}
    set {_uniqueStorage()._log = newValue}
  }

  public var result: Protocol_TransactionInfo.code {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var resMessage: Data {
    get {return _storage._resMessage}
    set {_uniqueStorage()._resMessage = newValue}
  }

  public var assetIssueID: String {
    get {return _storage._assetIssueID}
    set {_uniqueStorage()._assetIssueID = newValue}
  }

  public var withdrawAmount: Int64 {
    get {return _storage._withdrawAmount}
    set {_uniqueStorage()._withdrawAmount = newValue}
  }

  public var unfreezeAmount: Int64 {
    get {return _storage._unfreezeAmount}
    set {_uniqueStorage()._unfreezeAmount = newValue}
  }

  public var internalTransactions: [Protocol_InternalTransaction] {
    get {return _storage._internalTransactions}
    set {_uniqueStorage()._internalTransactions = newValue}
  }

  public var exchangeReceivedAmount: Int64 {
    get {return _storage._exchangeReceivedAmount}
    set {_uniqueStorage()._exchangeReceivedAmount = newValue}
  }

  public var exchangeInjectAnotherAmount: Int64 {
    get {return _storage._exchangeInjectAnotherAmount}
    set {_uniqueStorage()._exchangeInjectAnotherAmount = newValue}
  }

  public var exchangeWithdrawAnotherAmount: Int64 {
    get {return _storage._exchangeWithdrawAnotherAmount}
    set {_uniqueStorage()._exchangeWithdrawAnotherAmount = newValue}
  }

  public var exchangeID: Int64 {
    get {return _storage._exchangeID}
    set {_uniqueStorage()._exchangeID = newValue}
  }

  public var shieldedTransactionFee: Int64 {
    get {return _storage._shieldedTransactionFee}
    set {_uniqueStorage()._shieldedTransactionFee = newValue}
  }

  public var orderID: Data {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  public var orderDetails: [Protocol_MarketOrderDetail] {
    get {return _storage._orderDetails}
    set {_uniqueStorage()._orderDetails = newValue}
  }

  public var packingFee: Int64 {
    get {return _storage._packingFee}
    set {_uniqueStorage()._packingFee = newValue}
  }

  public var withdrawExpireAmount: Int64 {
    get {return _storage._withdrawExpireAmount}
    set {_uniqueStorage()._withdrawExpireAmount = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sucess // = 0
    case failed // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .sucess
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sucess
      case 1: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sucess: return 0
      case .failed: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Log {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var address: Data = Data()

    public var topics: [Data] = []

    public var data: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Protocol_TransactionInfo.code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_TransactionInfo.code] = [
    .sucess,
    .failed,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_TransactionRet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockNumber: Int64 = 0

  public var blockTimeStamp: Int64 = 0

  public var transactioninfo: [Protocol_TransactionInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_Transactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactions: [Protocol_Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TransactionSign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transaction: Protocol_Transaction {
    get {return _transaction ?? Protocol_Transaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  public var privateKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transaction: Protocol_Transaction? = nil
}

public struct Protocol_BlockHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: Protocol_BlockHeader.raw {
    get {return _rawData ?? Protocol_BlockHeader.raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {self._rawData = nil}

  public var witnessSignature: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestamp: Int64 = 0

    public var txTrieRoot: Data = Data()

    public var parentHash: Data = Data()

    ///bytes nonce = 5;
    ///bytes difficulty = 6;
    public var number: Int64 = 0

    public var witnessID: Int64 = 0

    public var witnessAddress: Data = Data()

    public var version: Int32 = 0

    public var accountStateRoot: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _rawData: Protocol_BlockHeader.raw? = nil
}

/// block
public struct Protocol_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactions: [Protocol_Transaction] = []

  public var blockHeader: Protocol_BlockHeader {
    get {return _blockHeader ?? Protocol_BlockHeader()}
    set {_blockHeader = newValue}
  }
  /// Returns true if `blockHeader` has been explicitly set.
  public var hasBlockHeader: Bool {return self._blockHeader != nil}
  /// Clears the value of `blockHeader`. Subsequent reads from it will return its default value.
  public mutating func clearBlockHeader() {self._blockHeader = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _blockHeader: Protocol_BlockHeader? = nil
}

public struct Protocol_ChainInventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Protocol_ChainInventory.BlockId] = []

  public var remainNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hash: Data = Data()

    public var number: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Inventory
public struct Protocol_BlockInventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Protocol_BlockInventory.BlockId] = []

  public var type: Protocol_BlockInventory.TypeEnum = .sync

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sync // = 0
    case advtise // = 1
    case fetch // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .sync
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sync
      case 1: self = .advtise
      case 2: self = .fetch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sync: return 0
      case .advtise: return 1
      case .fetch: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hash: Data = Data()

    public var number: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_BlockInventory.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_BlockInventory.TypeEnum] = [
    .sync,
    .advtise,
    .fetch,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_Inventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Protocol_Inventory.InventoryType = .trx

  public var ids: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum InventoryType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case trx // = 0
    case block // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .trx
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .trx
      case 1: self = .block
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .trx: return 0
      case .block: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Inventory.InventoryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Inventory.InventoryType] = [
    .trx,
    .block,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_Items {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Protocol_Items.ItemType = .err

  public var blocks: [Protocol_Block] = []

  public var blockHeaders: [Protocol_BlockHeader] = []

  public var transactions: [Protocol_Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ItemType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case err // = 0
    case trx // = 1
    case block // = 2
    case blockheader // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .err
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .err
      case 1: self = .trx
      case 2: self = .block
      case 3: self = .blockheader
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .err: return 0
      case .trx: return 1
      case .block: return 2
      case .blockheader: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Items.ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Items.ItemType] = [
    .err,
    .trx,
    .block,
    .blockheader,
  ]
}

#endif  // swift(>=4.2)

/// DynamicProperties
public struct Protocol_DynamicProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lastSolidityBlockNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DisconnectMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: Protocol_ReasonCode = .requested

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_HelloMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: Protocol_Endpoint {
    get {return _from ?? Protocol_Endpoint()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  public var version: Int32 = 0

  public var timestamp: Int64 = 0

  public var genesisBlockID: Protocol_HelloMessage.BlockId {
    get {return _genesisBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_genesisBlockID = newValue}
  }
  /// Returns true if `genesisBlockID` has been explicitly set.
  public var hasGenesisBlockID: Bool {return self._genesisBlockID != nil}
  /// Clears the value of `genesisBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearGenesisBlockID() {self._genesisBlockID = nil}

  public var solidBlockID: Protocol_HelloMessage.BlockId {
    get {return _solidBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_solidBlockID = newValue}
  }
  /// Returns true if `solidBlockID` has been explicitly set.
  public var hasSolidBlockID: Bool {return self._solidBlockID != nil}
  /// Clears the value of `solidBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearSolidBlockID() {self._solidBlockID = nil}

  public var headBlockID: Protocol_HelloMessage.BlockId {
    get {return _headBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_headBlockID = newValue}
  }
  /// Returns true if `headBlockID` has been explicitly set.
  public var hasHeadBlockID: Bool {return self._headBlockID != nil}
  /// Clears the value of `headBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearHeadBlockID() {self._headBlockID = nil}

  public var address: Data = Data()

  public var signature: Data = Data()

  public var nodeType: Int32 = 0

  public var lowestBlockNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hash: Data = Data()

    public var number: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _from: Protocol_Endpoint? = nil
  fileprivate var _genesisBlockID: Protocol_HelloMessage.BlockId? = nil
  fileprivate var _solidBlockID: Protocol_HelloMessage.BlockId? = nil
  fileprivate var _headBlockID: Protocol_HelloMessage.BlockId? = nil
}

public struct Protocol_InternalTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// internalTransaction identity, the root InternalTransaction hash
  /// should equals to root transaction id.
  public var hash: Data = Data()

  /// the one send trx (TBD: or token) via function
  public var callerAddress: Data = Data()

  /// the one recieve trx (TBD: or token) via function
  public var transferToAddress: Data = Data()

  public var callValueInfo: [Protocol_InternalTransaction.CallValueInfo] = []

  public var note: Data = Data()

  public var rejected: Bool = false

  public var extra: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct CallValueInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// trx (TBD: or token) value
    public var callValue: Int64 = 0

    /// TBD: tokenName, trx should be empty
    public var tokenID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Protocol_DelegatedResourceAccountIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Data = Data()

  public var fromAccounts: [Data] = []

  public var toAccounts: [Data] = []

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beginSyncNum: Int64 {
    get {return _storage._beginSyncNum}
    set {_uniqueStorage()._beginSyncNum = newValue}
  }

  public var block: String {
    get {return _storage._block}
    set {_uniqueStorage()._block = newValue}
  }

  public var solidityBlock: String {
    get {return _storage._solidityBlock}
    set {_uniqueStorage()._solidityBlock = newValue}
  }

  ///connect information
  public var currentConnectCount: Int32 {
    get {return _storage._currentConnectCount}
    set {_uniqueStorage()._currentConnectCount = newValue}
  }

  public var activeConnectCount: Int32 {
    get {return _storage._activeConnectCount}
    set {_uniqueStorage()._activeConnectCount = newValue}
  }

  public var passiveConnectCount: Int32 {
    get {return _storage._passiveConnectCount}
    set {_uniqueStorage()._passiveConnectCount = newValue}
  }

  public var totalFlow: Int64 {
    get {return _storage._totalFlow}
    set {_uniqueStorage()._totalFlow = newValue}
  }

  public var peerInfoList: [Protocol_NodeInfo.PeerInfo] {
    get {return _storage._peerInfoList}
    set {_uniqueStorage()._peerInfoList = newValue}
  }

  public var configNodeInfo: Protocol_NodeInfo.ConfigNodeInfo {
    get {return _storage._configNodeInfo ?? Protocol_NodeInfo.ConfigNodeInfo()}
    set {_uniqueStorage()._configNodeInfo = newValue}
  }
  /// Returns true if `configNodeInfo` has been explicitly set.
  public var hasConfigNodeInfo: Bool {return _storage._configNodeInfo != nil}
  /// Clears the value of `configNodeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearConfigNodeInfo() {_uniqueStorage()._configNodeInfo = nil}

  public var machineInfo: Protocol_NodeInfo.MachineInfo {
    get {return _storage._machineInfo ?? Protocol_NodeInfo.MachineInfo()}
    set {_uniqueStorage()._machineInfo = newValue}
  }
  /// Returns true if `machineInfo` has been explicitly set.
  public var hasMachineInfo: Bool {return _storage._machineInfo != nil}
  /// Clears the value of `machineInfo`. Subsequent reads from it will return its default value.
  public mutating func clearMachineInfo() {_uniqueStorage()._machineInfo = nil}

  public var cheatWitnessInfoMap: Dictionary<String,String> {
    get {return _storage._cheatWitnessInfoMap}
    set {_uniqueStorage()._cheatWitnessInfoMap = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct PeerInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var lastSyncBlock: String {
      get {return _storage._lastSyncBlock}
      set {_uniqueStorage()._lastSyncBlock = newValue}
    }

    public var remainNum: Int64 {
      get {return _storage._remainNum}
      set {_uniqueStorage()._remainNum = newValue}
    }

    public var lastBlockUpdateTime: Int64 {
      get {return _storage._lastBlockUpdateTime}
      set {_uniqueStorage()._lastBlockUpdateTime = newValue}
    }

    public var syncFlag: Bool {
      get {return _storage._syncFlag}
      set {_uniqueStorage()._syncFlag = newValue}
    }

    public var headBlockTimeWeBothHave: Int64 {
      get {return _storage._headBlockTimeWeBothHave}
      set {_uniqueStorage()._headBlockTimeWeBothHave = newValue}
    }

    public var needSyncFromPeer: Bool {
      get {return _storage._needSyncFromPeer}
      set {_uniqueStorage()._needSyncFromPeer = newValue}
    }

    public var needSyncFromUs: Bool {
      get {return _storage._needSyncFromUs}
      set {_uniqueStorage()._needSyncFromUs = newValue}
    }

    public var host: String {
      get {return _storage._host}
      set {_uniqueStorage()._host = newValue}
    }

    public var port: Int32 {
      get {return _storage._port}
      set {_uniqueStorage()._port = newValue}
    }

    public var nodeID: String {
      get {return _storage._nodeID}
      set {_uniqueStorage()._nodeID = newValue}
    }

    public var connectTime: Int64 {
      get {return _storage._connectTime}
      set {_uniqueStorage()._connectTime = newValue}
    }

    public var avgLatency: Double {
      get {return _storage._avgLatency}
      set {_uniqueStorage()._avgLatency = newValue}
    }

    public var syncToFetchSize: Int32 {
      get {return _storage._syncToFetchSize}
      set {_uniqueStorage()._syncToFetchSize = newValue}
    }

    public var syncToFetchSizePeekNum: Int64 {
      get {return _storage._syncToFetchSizePeekNum}
      set {_uniqueStorage()._syncToFetchSizePeekNum = newValue}
    }

    public var syncBlockRequestedSize: Int32 {
      get {return _storage._syncBlockRequestedSize}
      set {_uniqueStorage()._syncBlockRequestedSize = newValue}
    }

    public var unFetchSynNum: Int64 {
      get {return _storage._unFetchSynNum}
      set {_uniqueStorage()._unFetchSynNum = newValue}
    }

    public var blockInPorcSize: Int32 {
      get {return _storage._blockInPorcSize}
      set {_uniqueStorage()._blockInPorcSize = newValue}
    }

    public var headBlockWeBothHave: String {
      get {return _storage._headBlockWeBothHave}
      set {_uniqueStorage()._headBlockWeBothHave = newValue}
    }

    public var isActive: Bool {
      get {return _storage._isActive}
      set {_uniqueStorage()._isActive = newValue}
    }

    public var score: Int32 {
      get {return _storage._score}
      set {_uniqueStorage()._score = newValue}
    }

    public var nodeCount: Int32 {
      get {return _storage._nodeCount}
      set {_uniqueStorage()._nodeCount = newValue}
    }

    public var inFlow: Int64 {
      get {return _storage._inFlow}
      set {_uniqueStorage()._inFlow = newValue}
    }

    public var disconnectTimes: Int32 {
      get {return _storage._disconnectTimes}
      set {_uniqueStorage()._disconnectTimes = newValue}
    }

    public var localDisconnectReason: String {
      get {return _storage._localDisconnectReason}
      set {_uniqueStorage()._localDisconnectReason = newValue}
    }

    public var remoteDisconnectReason: String {
      get {return _storage._remoteDisconnectReason}
      set {_uniqueStorage()._remoteDisconnectReason = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ConfigNodeInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var codeVersion: String {
      get {return _storage._codeVersion}
      set {_uniqueStorage()._codeVersion = newValue}
    }

    public var p2PVersion: String {
      get {return _storage._p2PVersion}
      set {_uniqueStorage()._p2PVersion = newValue}
    }

    public var listenPort: Int32 {
      get {return _storage._listenPort}
      set {_uniqueStorage()._listenPort = newValue}
    }

    public var discoverEnable: Bool {
      get {return _storage._discoverEnable}
      set {_uniqueStorage()._discoverEnable = newValue}
    }

    public var activeNodeSize: Int32 {
      get {return _storage._activeNodeSize}
      set {_uniqueStorage()._activeNodeSize = newValue}
    }

    public var passiveNodeSize: Int32 {
      get {return _storage._passiveNodeSize}
      set {_uniqueStorage()._passiveNodeSize = newValue}
    }

    public var sendNodeSize: Int32 {
      get {return _storage._sendNodeSize}
      set {_uniqueStorage()._sendNodeSize = newValue}
    }

    public var maxConnectCount: Int32 {
      get {return _storage._maxConnectCount}
      set {_uniqueStorage()._maxConnectCount = newValue}
    }

    public var sameIpMaxConnectCount: Int32 {
      get {return _storage._sameIpMaxConnectCount}
      set {_uniqueStorage()._sameIpMaxConnectCount = newValue}
    }

    public var backupListenPort: Int32 {
      get {return _storage._backupListenPort}
      set {_uniqueStorage()._backupListenPort = newValue}
    }

    public var backupMemberSize: Int32 {
      get {return _storage._backupMemberSize}
      set {_uniqueStorage()._backupMemberSize = newValue}
    }

    public var backupPriority: Int32 {
      get {return _storage._backupPriority}
      set {_uniqueStorage()._backupPriority = newValue}
    }

    public var dbVersion: Int32 {
      get {return _storage._dbVersion}
      set {_uniqueStorage()._dbVersion = newValue}
    }

    public var minParticipationRate: Int32 {
      get {return _storage._minParticipationRate}
      set {_uniqueStorage()._minParticipationRate = newValue}
    }

    public var supportConstant: Bool {
      get {return _storage._supportConstant}
      set {_uniqueStorage()._supportConstant = newValue}
    }

    public var minTimeRatio: Double {
      get {return _storage._minTimeRatio}
      set {_uniqueStorage()._minTimeRatio = newValue}
    }

    public var maxTimeRatio: Double {
      get {return _storage._maxTimeRatio}
      set {_uniqueStorage()._maxTimeRatio = newValue}
    }

    public var allowCreationOfContracts: Int64 {
      get {return _storage._allowCreationOfContracts}
      set {_uniqueStorage()._allowCreationOfContracts = newValue}
    }

    public var allowAdaptiveEnergy: Int64 {
      get {return _storage._allowAdaptiveEnergy}
      set {_uniqueStorage()._allowAdaptiveEnergy = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct MachineInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var threadCount: Int32 = 0

    public var deadLockThreadCount: Int32 = 0

    public var cpuCount: Int32 = 0

    public var totalMemory: Int64 = 0

    public var freeMemory: Int64 = 0

    public var cpuRate: Double = 0

    public var javaVersion: String = String()

    public var osName: String = String()

    public var jvmTotalMemory: Int64 = 0

    public var jvmFreeMemory: Int64 = 0

    public var processCpuRate: Double = 0

    public var memoryDescInfoList: [Protocol_NodeInfo.MachineInfo.MemoryDescInfo] = []

    public var deadLockThreadInfoList: [Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct MemoryDescInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var initSize: Int64 = 0

      public var useSize: Int64 = 0

      public var maxSize: Int64 = 0

      public var useRate: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct DeadLockThreadInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var lockName: String = String()

      public var lockOwner: String = String()

      public var state: String = String()

      public var blockTime: Int64 = 0

      public var waitTime: Int64 = 0

      public var stackTrace: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protocol_MetricsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var interval: Int64 = 0

  public var node: Protocol_MetricsInfo.NodeInfo {
    get {return _node ?? Protocol_MetricsInfo.NodeInfo()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {self._node = nil}

  public var blockchain: Protocol_MetricsInfo.BlockChainInfo {
    get {return _blockchain ?? Protocol_MetricsInfo.BlockChainInfo()}
    set {_blockchain = newValue}
  }
  /// Returns true if `blockchain` has been explicitly set.
  public var hasBlockchain: Bool {return self._blockchain != nil}
  /// Clears the value of `blockchain`. Subsequent reads from it will return its default value.
  public mutating func clearBlockchain() {self._blockchain = nil}

  public var net: Protocol_MetricsInfo.NetInfo {
    get {return _net ?? Protocol_MetricsInfo.NetInfo()}
    set {_net = newValue}
  }
  /// Returns true if `net` has been explicitly set.
  public var hasNet: Bool {return self._net != nil}
  /// Clears the value of `net`. Subsequent reads from it will return its default value.
  public mutating func clearNet() {self._net = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct NodeInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ip: String = String()

    public var nodeType: Int32 = 0

    public var version: String = String()

    public var backupStatus: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BlockChainInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var headBlockNum: Int64 {
      get {return _storage._headBlockNum}
      set {_uniqueStorage()._headBlockNum = newValue}
    }

    public var headBlockTimestamp: Int64 {
      get {return _storage._headBlockTimestamp}
      set {_uniqueStorage()._headBlockTimestamp = newValue}
    }

    public var headBlockHash: String {
      get {return _storage._headBlockHash}
      set {_uniqueStorage()._headBlockHash = newValue}
    }

    public var forkCount: Int32 {
      get {return _storage._forkCount}
      set {_uniqueStorage()._forkCount = newValue}
    }

    public var failForkCount: Int32 {
      get {return _storage._failForkCount}
      set {_uniqueStorage()._failForkCount = newValue}
    }

    public var blockProcessTime: Protocol_MetricsInfo.RateInfo {
      get {return _storage._blockProcessTime ?? Protocol_MetricsInfo.RateInfo()}
      set {_uniqueStorage()._blockProcessTime = newValue}
    }
    /// Returns true if `blockProcessTime` has been explicitly set.
    public var hasBlockProcessTime: Bool {return _storage._blockProcessTime != nil}
    /// Clears the value of `blockProcessTime`. Subsequent reads from it will return its default value.
    public mutating func clearBlockProcessTime() {_uniqueStorage()._blockProcessTime = nil}

    public var tps: Protocol_MetricsInfo.RateInfo {
      get {return _storage._tps ?? Protocol_MetricsInfo.RateInfo()}
      set {_uniqueStorage()._tps = newValue}
    }
    /// Returns true if `tps` has been explicitly set.
    public var hasTps: Bool {return _storage._tps != nil}
    /// Clears the value of `tps`. Subsequent reads from it will return its default value.
    public mutating func clearTps() {_uniqueStorage()._tps = nil}

    public var transactionCacheSize: Int32 {
      get {return _storage._transactionCacheSize}
      set {_uniqueStorage()._transactionCacheSize = newValue}
    }

    public var missedTransaction: Protocol_MetricsInfo.RateInfo {
      get {return _storage._missedTransaction ?? Protocol_MetricsInfo.RateInfo()}
      set {_uniqueStorage()._missedTransaction = newValue}
    }
    /// Returns true if `missedTransaction` has been explicitly set.
    public var hasMissedTransaction: Bool {return _storage._missedTransaction != nil}
    /// Clears the value of `missedTransaction`. Subsequent reads from it will return its default value.
    public mutating func clearMissedTransaction() {_uniqueStorage()._missedTransaction = nil}

    public var witnesses: [Protocol_MetricsInfo.BlockChainInfo.Witness] {
      get {return _storage._witnesses}
      set {_uniqueStorage()._witnesses = newValue}
    }

    public var failProcessBlockNum: Int64 {
      get {return _storage._failProcessBlockNum}
      set {_uniqueStorage()._failProcessBlockNum = newValue}
    }

    public var failProcessBlockReason: String {
      get {return _storage._failProcessBlockReason}
      set {_uniqueStorage()._failProcessBlockReason = newValue}
    }

    public var dupWitness: [Protocol_MetricsInfo.BlockChainInfo.DupWitness] {
      get {return _storage._dupWitness}
      set {_uniqueStorage()._dupWitness = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Witness {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var address: String = String()

      public var version: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct DupWitness {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var address: String = String()

      public var blockNum: Int64 = 0

      public var count: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct RateInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var count: Int64 = 0

    public var meanRate: Double = 0

    public var oneMinuteRate: Double = 0

    public var fiveMinuteRate: Double = 0

    public var fifteenMinuteRate: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct NetInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var errorProtoCount: Int32 {
      get {return _storage._errorProtoCount}
      set {_uniqueStorage()._errorProtoCount = newValue}
    }

    public var api: Protocol_MetricsInfo.NetInfo.ApiInfo {
      get {return _storage._api ?? Protocol_MetricsInfo.NetInfo.ApiInfo()}
      set {_uniqueStorage()._api = newValue}
    }
    /// Returns true if `api` has been explicitly set.
    public var hasApi: Bool {return _storage._api != nil}
    /// Clears the value of `api`. Subsequent reads from it will return its default value.
    public mutating func clearApi() {_uniqueStorage()._api = nil}

    public var connectionCount: Int32 {
      get {return _storage._connectionCount}
      set {_uniqueStorage()._connectionCount = newValue}
    }

    public var validConnectionCount: Int32 {
      get {return _storage._validConnectionCount}
      set {_uniqueStorage()._validConnectionCount = newValue}
    }

    public var tcpInTraffic: Protocol_MetricsInfo.RateInfo {
      get {return _storage._tcpInTraffic ?? Protocol_MetricsInfo.RateInfo()}
      set {_uniqueStorage()._tcpInTraffic = newValue}
    }
    /// Returns true if `tcpInTraffic` has been explicitly set.
    public var hasTcpInTraffic: Bool {return _storage._tcpInTraffic != nil}
    /// Clears the value of `tcpInTraffic`. Subsequent reads from it will return its default value.
    public mutating func clearTcpInTraffic() {_uniqueStorage()._tcpInTraffic = nil}

    public var tcpOutTraffic: Protocol_MetricsInfo.RateInfo {
      get {return _storage._tcpOutTraffic ?? Protocol_MetricsInfo.RateInfo()}
      set {_uniqueStorage()._tcpOutTraffic = newValue}
    }
    /// Returns true if `tcpOutTraffic` has been explicitly set.
    public var hasTcpOutTraffic: Bool {return _storage._tcpOutTraffic != nil}
    /// Clears the value of `tcpOutTraffic`. Subsequent reads from it will return its default value.
    public mutating func clearTcpOutTraffic() {_uniqueStorage()._tcpOutTraffic = nil}

    public var disconnectionCount: Int32 {
      get {return _storage._disconnectionCount}
      set {_uniqueStorage()._disconnectionCount = newValue}
    }

    public var disconnectionDetail: [Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo] {
      get {return _storage._disconnectionDetail}
      set {_uniqueStorage()._disconnectionDetail = newValue}
    }

    public var udpInTraffic: Protocol_MetricsInfo.RateInfo {
      get {return _storage._udpInTraffic ?? Protocol_MetricsInfo.RateInfo()}
      set {_uniqueStorage()._udpInTraffic = newValue}
    }
    /// Returns true if `udpInTraffic` has been explicitly set.
    public var hasUdpInTraffic: Bool {return _storage._udpInTraffic != nil}
    /// Clears the value of `udpInTraffic`. Subsequent reads from it will return its default value.
    public mutating func clearUdpInTraffic() {_uniqueStorage()._udpInTraffic = nil}

    public var udpOutTraffic: Protocol_MetricsInfo.RateInfo {
      get {return _storage._udpOutTraffic ?? Protocol_MetricsInfo.RateInfo()}
      set {_uniqueStorage()._udpOutTraffic = newValue}
    }
    /// Returns true if `udpOutTraffic` has been explicitly set.
    public var hasUdpOutTraffic: Bool {return _storage._udpOutTraffic != nil}
    /// Clears the value of `udpOutTraffic`. Subsequent reads from it will return its default value.
    public mutating func clearUdpOutTraffic() {_uniqueStorage()._udpOutTraffic = nil}

    public var latency: Protocol_MetricsInfo.NetInfo.LatencyInfo {
      get {return _storage._latency ?? Protocol_MetricsInfo.NetInfo.LatencyInfo()}
      set {_uniqueStorage()._latency = newValue}
    }
    /// Returns true if `latency` has been explicitly set.
    public var hasLatency: Bool {return _storage._latency != nil}
    /// Clears the value of `latency`. Subsequent reads from it will return its default value.
    public mutating func clearLatency() {_uniqueStorage()._latency = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ApiInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var qps: Protocol_MetricsInfo.RateInfo {
        get {return _qps ?? Protocol_MetricsInfo.RateInfo()}
        set {_qps = newValue}
      }
      /// Returns true if `qps` has been explicitly set.
      public var hasQps: Bool {return self._qps != nil}
      /// Clears the value of `qps`. Subsequent reads from it will return its default value.
      public mutating func clearQps() {self._qps = nil}

      public var failQps: Protocol_MetricsInfo.RateInfo {
        get {return _failQps ?? Protocol_MetricsInfo.RateInfo()}
        set {_failQps = newValue}
      }
      /// Returns true if `failQps` has been explicitly set.
      public var hasFailQps: Bool {return self._failQps != nil}
      /// Clears the value of `failQps`. Subsequent reads from it will return its default value.
      public mutating func clearFailQps() {self._failQps = nil}

      public var outTraffic: Protocol_MetricsInfo.RateInfo {
        get {return _outTraffic ?? Protocol_MetricsInfo.RateInfo()}
        set {_outTraffic = newValue}
      }
      /// Returns true if `outTraffic` has been explicitly set.
      public var hasOutTraffic: Bool {return self._outTraffic != nil}
      /// Clears the value of `outTraffic`. Subsequent reads from it will return its default value.
      public mutating func clearOutTraffic() {self._outTraffic = nil}

      public var detail: [Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct ApiDetailInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var qps: Protocol_MetricsInfo.RateInfo {
          get {return _qps ?? Protocol_MetricsInfo.RateInfo()}
          set {_qps = newValue}
        }
        /// Returns true if `qps` has been explicitly set.
        public var hasQps: Bool {return self._qps != nil}
        /// Clears the value of `qps`. Subsequent reads from it will return its default value.
        public mutating func clearQps() {self._qps = nil}

        public var failQps: Protocol_MetricsInfo.RateInfo {
          get {return _failQps ?? Protocol_MetricsInfo.RateInfo()}
          set {_failQps = newValue}
        }
        /// Returns true if `failQps` has been explicitly set.
        public var hasFailQps: Bool {return self._failQps != nil}
        /// Clears the value of `failQps`. Subsequent reads from it will return its default value.
        public mutating func clearFailQps() {self._failQps = nil}

        public var outTraffic: Protocol_MetricsInfo.RateInfo {
          get {return _outTraffic ?? Protocol_MetricsInfo.RateInfo()}
          set {_outTraffic = newValue}
        }
        /// Returns true if `outTraffic` has been explicitly set.
        public var hasOutTraffic: Bool {return self._outTraffic != nil}
        /// Clears the value of `outTraffic`. Subsequent reads from it will return its default value.
        public mutating func clearOutTraffic() {self._outTraffic = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _qps: Protocol_MetricsInfo.RateInfo? = nil
        fileprivate var _failQps: Protocol_MetricsInfo.RateInfo? = nil
        fileprivate var _outTraffic: Protocol_MetricsInfo.RateInfo? = nil
      }

      public init() {}

      fileprivate var _qps: Protocol_MetricsInfo.RateInfo? = nil
      fileprivate var _failQps: Protocol_MetricsInfo.RateInfo? = nil
      fileprivate var _outTraffic: Protocol_MetricsInfo.RateInfo? = nil
    }

    public struct DisconnectionDetailInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var reason: String = String()

      public var count: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct LatencyInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var top99: Int32 = 0

      public var top95: Int32 = 0

      public var top75: Int32 = 0

      public var totalCount: Int32 = 0

      public var delay1S: Int32 = 0

      public var delay2S: Int32 = 0

      public var delay3S: Int32 = 0

      public var detail: [Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct LatencyDetailInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var witness: String = String()

        public var top99: Int32 = 0

        public var top95: Int32 = 0

        public var top75: Int32 = 0

        public var count: Int32 = 0

        public var delay1S: Int32 = 0

        public var delay2S: Int32 = 0

        public var delay3S: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _node: Protocol_MetricsInfo.NodeInfo? = nil
  fileprivate var _blockchain: Protocol_MetricsInfo.BlockChainInfo? = nil
  fileprivate var _net: Protocol_MetricsInfo.NetInfo? = nil
}

public struct Protocol_PBFTMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: Protocol_PBFTMessage.Raw {
    get {return _rawData ?? Protocol_PBFTMessage.Raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {self._rawData = nil}

  public var signature: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MsgType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case viewChange // = 0
    case request // = 1
    case preprepare // = 2
    case prepare // = 3
    case commit // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .viewChange
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .viewChange
      case 1: self = .request
      case 2: self = .preprepare
      case 3: self = .prepare
      case 4: self = .commit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .viewChange: return 0
      case .request: return 1
      case .preprepare: return 2
      case .prepare: return 3
      case .commit: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum DataType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case block // = 0
    case srl // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .block
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .block
      case 1: self = .srl
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .block: return 0
      case .srl: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var msgType: Protocol_PBFTMessage.MsgType = .viewChange

    public var dataType: Protocol_PBFTMessage.DataType = .block

    public var viewN: Int64 = 0

    public var epoch: Int64 = 0

    public var data: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _rawData: Protocol_PBFTMessage.Raw? = nil
}

#if swift(>=4.2)

extension Protocol_PBFTMessage.MsgType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_PBFTMessage.MsgType] = [
    .viewChange,
    .request,
    .preprepare,
    .prepare,
    .commit,
  ]
}

extension Protocol_PBFTMessage.DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_PBFTMessage.DataType] = [
    .block,
    .srl,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_PBFTCommitResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var signature: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_SRL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var srAddress: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Protocol_AccountType: @unchecked Sendable {}
extension Protocol_ReasonCode: @unchecked Sendable {}
extension Protocol_AccountId: @unchecked Sendable {}
extension Protocol_Vote: @unchecked Sendable {}
extension Protocol_Proposal: @unchecked Sendable {}
extension Protocol_Proposal.State: @unchecked Sendable {}
extension Protocol_Exchange: @unchecked Sendable {}
extension Protocol_MarketOrder: @unchecked Sendable {}
extension Protocol_MarketOrder.State: @unchecked Sendable {}
extension Protocol_MarketOrderList: @unchecked Sendable {}
extension Protocol_MarketOrderPairList: @unchecked Sendable {}
extension Protocol_MarketOrderPair: @unchecked Sendable {}
extension Protocol_MarketAccountOrder: @unchecked Sendable {}
extension Protocol_MarketPrice: @unchecked Sendable {}
extension Protocol_MarketPriceList: @unchecked Sendable {}
extension Protocol_MarketOrderIdList: @unchecked Sendable {}
extension Protocol_ChainParameters: @unchecked Sendable {}
extension Protocol_ChainParameters.ChainParameter: @unchecked Sendable {}
extension Protocol_Account: @unchecked Sendable {}
extension Protocol_Account.Frozen: @unchecked Sendable {}
extension Protocol_Account.AccountResource: @unchecked Sendable {}
extension Protocol_Account.FreezeV2: @unchecked Sendable {}
extension Protocol_Account.UnFreezeV2: @unchecked Sendable {}
extension Protocol_Key: @unchecked Sendable {}
extension Protocol_DelegatedResource: @unchecked Sendable {}
extension Protocol_authority: @unchecked Sendable {}
extension Protocol_Permission: @unchecked Sendable {}
extension Protocol_Permission.PermissionType: @unchecked Sendable {}
extension Protocol_Witness: @unchecked Sendable {}
extension Protocol_Votes: @unchecked Sendable {}
extension Protocol_TXOutput: @unchecked Sendable {}
extension Protocol_TXInput: @unchecked Sendable {}
extension Protocol_TXInput.raw: @unchecked Sendable {}
extension Protocol_TXOutputs: @unchecked Sendable {}
extension Protocol_ResourceReceipt: @unchecked Sendable {}
extension Protocol_MarketOrderDetail: @unchecked Sendable {}
extension Protocol_Transaction: @unchecked Sendable {}
extension Protocol_Transaction.Contract: @unchecked Sendable {}
extension Protocol_Transaction.Contract.ContractType: @unchecked Sendable {}
extension Protocol_Transaction.Result: @unchecked Sendable {}
extension Protocol_Transaction.Result.code: @unchecked Sendable {}
extension Protocol_Transaction.Result.contractResult: @unchecked Sendable {}
extension Protocol_Transaction.raw: @unchecked Sendable {}
extension Protocol_TransactionInfo: @unchecked Sendable {}
extension Protocol_TransactionInfo.code: @unchecked Sendable {}
extension Protocol_TransactionInfo.Log: @unchecked Sendable {}
extension Protocol_TransactionRet: @unchecked Sendable {}
extension Protocol_Transactions: @unchecked Sendable {}
extension Protocol_TransactionSign: @unchecked Sendable {}
extension Protocol_BlockHeader: @unchecked Sendable {}
extension Protocol_BlockHeader.raw: @unchecked Sendable {}
extension Protocol_Block: @unchecked Sendable {}
extension Protocol_ChainInventory: @unchecked Sendable {}
extension Protocol_ChainInventory.BlockId: @unchecked Sendable {}
extension Protocol_BlockInventory: @unchecked Sendable {}
extension Protocol_BlockInventory.TypeEnum: @unchecked Sendable {}
extension Protocol_BlockInventory.BlockId: @unchecked Sendable {}
extension Protocol_Inventory: @unchecked Sendable {}
extension Protocol_Inventory.InventoryType: @unchecked Sendable {}
extension Protocol_Items: @unchecked Sendable {}
extension Protocol_Items.ItemType: @unchecked Sendable {}
extension Protocol_DynamicProperties: @unchecked Sendable {}
extension Protocol_DisconnectMessage: @unchecked Sendable {}
extension Protocol_HelloMessage: @unchecked Sendable {}
extension Protocol_HelloMessage.BlockId: @unchecked Sendable {}
extension Protocol_InternalTransaction: @unchecked Sendable {}
extension Protocol_InternalTransaction.CallValueInfo: @unchecked Sendable {}
extension Protocol_DelegatedResourceAccountIndex: @unchecked Sendable {}
extension Protocol_NodeInfo: @unchecked Sendable {}
extension Protocol_NodeInfo.PeerInfo: @unchecked Sendable {}
extension Protocol_NodeInfo.ConfigNodeInfo: @unchecked Sendable {}
extension Protocol_NodeInfo.MachineInfo: @unchecked Sendable {}
extension Protocol_NodeInfo.MachineInfo.MemoryDescInfo: @unchecked Sendable {}
extension Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.NodeInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.BlockChainInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.BlockChainInfo.Witness: @unchecked Sendable {}
extension Protocol_MetricsInfo.BlockChainInfo.DupWitness: @unchecked Sendable {}
extension Protocol_MetricsInfo.RateInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.NetInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.NetInfo.ApiInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.NetInfo.LatencyInfo: @unchecked Sendable {}
extension Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo: @unchecked Sendable {}
extension Protocol_PBFTMessage: @unchecked Sendable {}
extension Protocol_PBFTMessage.MsgType: @unchecked Sendable {}
extension Protocol_PBFTMessage.DataType: @unchecked Sendable {}
extension Protocol_PBFTMessage.Raw: @unchecked Sendable {}
extension Protocol_PBFTCommitResult: @unchecked Sendable {}
extension Protocol_SRL: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_AccountType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Normal"),
    1: .same(proto: "AssetIssue"),
    2: .same(proto: "Contract"),
  ]
}

extension Protocol_ReasonCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUESTED"),
    2: .same(proto: "BAD_PROTOCOL"),
    4: .same(proto: "TOO_MANY_PEERS"),
    5: .same(proto: "DUPLICATE_PEER"),
    6: .same(proto: "INCOMPATIBLE_PROTOCOL"),
    7: .same(proto: "RANDOM_ELIMINATION"),
    8: .same(proto: "PEER_QUITING"),
    9: .same(proto: "UNEXPECTED_IDENTITY"),
    10: .same(proto: "LOCAL_IDENTITY"),
    11: .same(proto: "PING_TIMEOUT"),
    16: .same(proto: "USER_REASON"),
    17: .same(proto: "RESET"),
    18: .same(proto: "SYNC_FAIL"),
    19: .same(proto: "FETCH_FAIL"),
    20: .same(proto: "BAD_TX"),
    21: .same(proto: "BAD_BLOCK"),
    22: .same(proto: "FORKED"),
    23: .same(proto: "UNLINKABLE"),
    24: .same(proto: "INCOMPATIBLE_VERSION"),
    25: .same(proto: "INCOMPATIBLE_CHAIN"),
    32: .same(proto: "TIME_OUT"),
    33: .same(proto: "CONNECT_FAIL"),
    34: .same(proto: "TOO_MANY_PEERS_WITH_SAME_IP"),
    35: .same(proto: "LIGHT_NODE_SYNC_FAIL"),
    255: .same(proto: "UNKNOWN"),
  ]
}

extension Protocol_AccountId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_AccountId, rhs: Protocol_AccountId) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_address"),
    2: .standard(proto: "vote_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.voteAddress) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.voteCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voteAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteAddress, fieldNumber: 1)
    }
    if self.voteCount != 0 {
      try visitor.visitSingularInt64Field(value: self.voteCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Vote, rhs: Protocol_Vote) -> Bool {
    if lhs.voteAddress != rhs.voteAddress {return false}
    if lhs.voteCount != rhs.voteCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Proposal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .standard(proto: "proposer_address"),
    3: .same(proto: "parameters"),
    4: .standard(proto: "expiration_time"),
    5: .standard(proto: "create_time"),
    6: .same(proto: "approvals"),
    7: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.proposalID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: &self.parameters) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expirationTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.approvals) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 1)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 2)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: self.parameters, fieldNumber: 3)
    }
    if self.expirationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationTime, fieldNumber: 4)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 5)
    }
    if !self.approvals.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.approvals, fieldNumber: 6)
    }
    if self.state != .pending {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Proposal, rhs: Protocol_Proposal) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.expirationTime != rhs.expirationTime {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.approvals != rhs.approvals {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Proposal.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "DISAPPROVED"),
    2: .same(proto: "APPROVED"),
    3: .same(proto: "CANCELED"),
  ]
}

extension Protocol_Exchange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Exchange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "creator_address"),
    3: .standard(proto: "create_time"),
    6: .standard(proto: "first_token_id"),
    7: .standard(proto: "first_token_balance"),
    8: .standard(proto: "second_token_id"),
    9: .standard(proto: "second_token_balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.exchangeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.creatorAddress) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.firstTokenID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.firstTokenBalance) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.secondTokenID) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.secondTokenBalance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.creatorAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.creatorAddress, fieldNumber: 2)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 3)
    }
    if !self.firstTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.firstTokenID, fieldNumber: 6)
    }
    if self.firstTokenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.firstTokenBalance, fieldNumber: 7)
    }
    if !self.secondTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.secondTokenID, fieldNumber: 8)
    }
    if self.secondTokenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.secondTokenBalance, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Exchange, rhs: Protocol_Exchange) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.creatorAddress != rhs.creatorAddress {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.firstTokenID != rhs.firstTokenID {return false}
    if lhs.firstTokenBalance != rhs.firstTokenBalance {return false}
    if lhs.secondTokenID != rhs.secondTokenID {return false}
    if lhs.secondTokenBalance != rhs.secondTokenBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "create_time"),
    4: .standard(proto: "sell_token_id"),
    5: .standard(proto: "sell_token_quantity"),
    6: .standard(proto: "buy_token_id"),
    7: .standard(proto: "buy_token_quantity"),
    9: .standard(proto: "sell_token_quantity_remain"),
    10: .standard(proto: "sell_token_quantity_return"),
    11: .same(proto: "state"),
    12: .same(proto: "prev"),
    13: .same(proto: "next"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.orderID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ownerAddress) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.sellTokenID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.sellTokenQuantity) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.buyTokenID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.buyTokenQuantity) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.sellTokenQuantityRemain) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.sellTokenQuantityReturn) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.prev) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self.next) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderID, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 2)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 3)
    }
    if !self.sellTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sellTokenID, fieldNumber: 4)
    }
    if self.sellTokenQuantity != 0 {
      try visitor.visitSingularInt64Field(value: self.sellTokenQuantity, fieldNumber: 5)
    }
    if !self.buyTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.buyTokenID, fieldNumber: 6)
    }
    if self.buyTokenQuantity != 0 {
      try visitor.visitSingularInt64Field(value: self.buyTokenQuantity, fieldNumber: 7)
    }
    if self.sellTokenQuantityRemain != 0 {
      try visitor.visitSingularInt64Field(value: self.sellTokenQuantityRemain, fieldNumber: 9)
    }
    if self.sellTokenQuantityReturn != 0 {
      try visitor.visitSingularInt64Field(value: self.sellTokenQuantityReturn, fieldNumber: 10)
    }
    if self.state != .active {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 11)
    }
    if !self.prev.isEmpty {
      try visitor.visitSingularBytesField(value: self.prev, fieldNumber: 12)
    }
    if !self.next.isEmpty {
      try visitor.visitSingularBytesField(value: self.next, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketOrder, rhs: Protocol_MarketOrder) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.sellTokenID != rhs.sellTokenID {return false}
    if lhs.sellTokenQuantity != rhs.sellTokenQuantity {return false}
    if lhs.buyTokenID != rhs.buyTokenID {return false}
    if lhs.buyTokenQuantity != rhs.buyTokenQuantity {return false}
    if lhs.sellTokenQuantityRemain != rhs.sellTokenQuantityRemain {return false}
    if lhs.sellTokenQuantityReturn != rhs.sellTokenQuantityReturn {return false}
    if lhs.state != rhs.state {return false}
    if lhs.prev != rhs.prev {return false}
    if lhs.next != rhs.next {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketOrder.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVE"),
    1: .same(proto: "INACTIVE"),
    2: .same(proto: "CANCELED"),
  ]
}

extension Protocol_MarketOrderList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketOrderList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orders"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orders) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orders, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketOrderList, rhs: Protocol_MarketOrderList) -> Bool {
    if lhs.orders != rhs.orders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketOrderPairList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketOrderPairList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderPair"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.orderPair) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderPair.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderPair, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketOrderPairList, rhs: Protocol_MarketOrderPairList) -> Bool {
    if lhs.orderPair != rhs.orderPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketOrderPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketOrderPair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sell_token_id"),
    2: .standard(proto: "buy_token_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sellTokenID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.buyTokenID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sellTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sellTokenID, fieldNumber: 1)
    }
    if !self.buyTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.buyTokenID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketOrderPair, rhs: Protocol_MarketOrderPair) -> Bool {
    if lhs.sellTokenID != rhs.sellTokenID {return false}
    if lhs.buyTokenID != rhs.buyTokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketAccountOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketAccountOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .same(proto: "orders"),
    3: .same(proto: "count"),
    4: .standard(proto: "total_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ownerAddress) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.orders) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.orders.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.orders, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketAccountOrder, rhs: Protocol_MarketAccountOrder) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.orders != rhs.orders {return false}
    if lhs.count != rhs.count {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketPrice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sell_token_quantity"),
    2: .standard(proto: "buy_token_quantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.sellTokenQuantity) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.buyTokenQuantity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sellTokenQuantity != 0 {
      try visitor.visitSingularInt64Field(value: self.sellTokenQuantity, fieldNumber: 1)
    }
    if self.buyTokenQuantity != 0 {
      try visitor.visitSingularInt64Field(value: self.buyTokenQuantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketPrice, rhs: Protocol_MarketPrice) -> Bool {
    if lhs.sellTokenQuantity != rhs.sellTokenQuantity {return false}
    if lhs.buyTokenQuantity != rhs.buyTokenQuantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketPriceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketPriceList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sell_token_id"),
    2: .standard(proto: "buy_token_id"),
    3: .same(proto: "prices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sellTokenID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.buyTokenID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.prices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sellTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sellTokenID, fieldNumber: 1)
    }
    if !self.buyTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.buyTokenID, fieldNumber: 2)
    }
    if !self.prices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prices, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketPriceList, rhs: Protocol_MarketPriceList) -> Bool {
    if lhs.sellTokenID != rhs.sellTokenID {return false}
    if lhs.buyTokenID != rhs.buyTokenID {return false}
    if lhs.prices != rhs.prices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketOrderIdList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketOrderIdList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "head"),
    2: .same(proto: "tail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.head) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.head.isEmpty {
      try visitor.visitSingularBytesField(value: self.head, fieldNumber: 1)
    }
    if !self.tail.isEmpty {
      try visitor.visitSingularBytesField(value: self.tail, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketOrderIdList, rhs: Protocol_MarketOrderIdList) -> Bool {
    if lhs.head != rhs.head {return false}
    if lhs.tail != rhs.tail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainParameter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chainParameter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainParameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chainParameter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ChainParameters, rhs: Protocol_ChainParameters) -> Bool {
    if lhs.chainParameter != rhs.chainParameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainParameters.ChainParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_ChainParameters.protoMessageName + ".ChainParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ChainParameters.ChainParameter, rhs: Protocol_ChainParameters.ChainParameter) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Account"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_name"),
    2: .same(proto: "type"),
    3: .same(proto: "address"),
    4: .same(proto: "balance"),
    5: .same(proto: "votes"),
    6: .same(proto: "asset"),
    56: .same(proto: "assetV2"),
    7: .same(proto: "frozen"),
    8: .standard(proto: "net_usage"),
    41: .standard(proto: "acquired_delegated_frozen_balance_for_bandwidth"),
    42: .standard(proto: "delegated_frozen_balance_for_bandwidth"),
    46: .standard(proto: "old_tron_power"),
    47: .standard(proto: "tron_power"),
    60: .standard(proto: "asset_optimized"),
    9: .standard(proto: "create_time"),
    10: .standard(proto: "latest_opration_time"),
    11: .same(proto: "allowance"),
    12: .standard(proto: "latest_withdraw_time"),
    13: .same(proto: "code"),
    14: .standard(proto: "is_witness"),
    15: .standard(proto: "is_committee"),
    16: .standard(proto: "frozen_supply"),
    17: .standard(proto: "asset_issued_name"),
    57: .standard(proto: "asset_issued_ID"),
    18: .standard(proto: "latest_asset_operation_time"),
    58: .standard(proto: "latest_asset_operation_timeV2"),
    19: .standard(proto: "free_net_usage"),
    20: .standard(proto: "free_asset_net_usage"),
    59: .standard(proto: "free_asset_net_usageV2"),
    21: .standard(proto: "latest_consume_time"),
    22: .standard(proto: "latest_consume_free_time"),
    23: .standard(proto: "account_id"),
    24: .standard(proto: "net_window_size"),
    26: .standard(proto: "account_resource"),
    30: .same(proto: "codeHash"),
    31: .standard(proto: "owner_permission"),
    32: .standard(proto: "witness_permission"),
    33: .standard(proto: "active_permission"),
    34: .same(proto: "frozenV2"),
    35: .same(proto: "unfrozenV2"),
    36: .standard(proto: "delegated_frozenV2_balance_for_bandwidth"),
    37: .standard(proto: "acquired_delegated_frozenV2_balance_for_bandwidth"),
  ]

  fileprivate class _StorageClass {
    var _accountName: Data = Data()
    var _type: Protocol_AccountType = .normal
    var _address: Data = Data()
    var _balance: Int64 = 0
    var _votes: [Protocol_Vote] = []
    var _asset: Dictionary<String,Int64> = [:]
    var _assetV2: Dictionary<String,Int64> = [:]
    var _frozen: [Protocol_Account.Frozen] = []
    var _netUsage: Int64 = 0
    var _acquiredDelegatedFrozenBalanceForBandwidth: Int64 = 0
    var _delegatedFrozenBalanceForBandwidth: Int64 = 0
    var _oldTronPower: Int64 = 0
    var _tronPower: Protocol_Account.Frozen? = nil
    var _assetOptimized: Bool = false
    var _createTime: Int64 = 0
    var _latestOprationTime: Int64 = 0
    var _allowance: Int64 = 0
    var _latestWithdrawTime: Int64 = 0
    var _code: Data = Data()
    var _isWitness: Bool = false
    var _isCommittee: Bool = false
    var _frozenSupply: [Protocol_Account.Frozen] = []
    var _assetIssuedName: Data = Data()
    var _assetIssuedID: Data = Data()
    var _latestAssetOperationTime: Dictionary<String,Int64> = [:]
    var _latestAssetOperationTimeV2: Dictionary<String,Int64> = [:]
    var _freeNetUsage: Int64 = 0
    var _freeAssetNetUsage: Dictionary<String,Int64> = [:]
    var _freeAssetNetUsageV2: Dictionary<String,Int64> = [:]
    var _latestConsumeTime: Int64 = 0
    var _latestConsumeFreeTime: Int64 = 0
    var _accountID: Data = Data()
    var _netWindowSize: Int64 = 0
    var _accountResource: Protocol_Account.AccountResource? = nil
    var _codeHash: Data = Data()
    var _ownerPermission: Protocol_Permission? = nil
    var _witnessPermission: Protocol_Permission? = nil
    var _activePermission: [Protocol_Permission] = []
    var _frozenV2: [Protocol_Account.FreezeV2] = []
    var _unfrozenV2: [Protocol_Account.UnFreezeV2] = []
    var _delegatedFrozenV2BalanceForBandwidth: Int64 = 0
    var _acquiredDelegatedFrozenV2BalanceForBandwidth: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountName = source._accountName
      _type = source._type
      _address = source._address
      _balance = source._balance
      _votes = source._votes
      _asset = source._asset
      _assetV2 = source._assetV2
      _frozen = source._frozen
      _netUsage = source._netUsage
      _acquiredDelegatedFrozenBalanceForBandwidth = source._acquiredDelegatedFrozenBalanceForBandwidth
      _delegatedFrozenBalanceForBandwidth = source._delegatedFrozenBalanceForBandwidth
      _oldTronPower = source._oldTronPower
      _tronPower = source._tronPower
      _assetOptimized = source._assetOptimized
      _createTime = source._createTime
      _latestOprationTime = source._latestOprationTime
      _allowance = source._allowance
      _latestWithdrawTime = source._latestWithdrawTime
      _code = source._code
      _isWitness = source._isWitness
      _isCommittee = source._isCommittee
      _frozenSupply = source._frozenSupply
      _assetIssuedName = source._assetIssuedName
      _assetIssuedID = source._assetIssuedID
      _latestAssetOperationTime = source._latestAssetOperationTime
      _latestAssetOperationTimeV2 = source._latestAssetOperationTimeV2
      _freeNetUsage = source._freeNetUsage
      _freeAssetNetUsage = source._freeAssetNetUsage
      _freeAssetNetUsageV2 = source._freeAssetNetUsageV2
      _latestConsumeTime = source._latestConsumeTime
      _latestConsumeFreeTime = source._latestConsumeFreeTime
      _accountID = source._accountID
      _netWindowSize = source._netWindowSize
      _accountResource = source._accountResource
      _codeHash = source._codeHash
      _ownerPermission = source._ownerPermission
      _witnessPermission = source._witnessPermission
      _activePermission = source._activePermission
      _frozenV2 = source._frozenV2
      _unfrozenV2 = source._unfrozenV2
      _delegatedFrozenV2BalanceForBandwidth = source._delegatedFrozenV2BalanceForBandwidth
      _acquiredDelegatedFrozenV2BalanceForBandwidth = source._acquiredDelegatedFrozenV2BalanceForBandwidth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._accountName) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._address) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._balance) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._votes) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._asset) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._frozen) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._netUsage) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._latestOprationTime) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._allowance) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._latestWithdrawTime) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._code) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isWitness) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isCommittee) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._frozenSupply) }()
        case 17: try { try decoder.decodeSingularBytesField(value: &_storage._assetIssuedName) }()
        case 18: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._latestAssetOperationTime) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._freeNetUsage) }()
        case 20: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._freeAssetNetUsage) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeTime) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeFreeTime) }()
        case 23: try { try decoder.decodeSingularBytesField(value: &_storage._accountID) }()
        case 24: try { try decoder.decodeSingularInt64Field(value: &_storage._netWindowSize) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._accountResource) }()
        case 30: try { try decoder.decodeSingularBytesField(value: &_storage._codeHash) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._ownerPermission) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._witnessPermission) }()
        case 33: try { try decoder.decodeRepeatedMessageField(value: &_storage._activePermission) }()
        case 34: try { try decoder.decodeRepeatedMessageField(value: &_storage._frozenV2) }()
        case 35: try { try decoder.decodeRepeatedMessageField(value: &_storage._unfrozenV2) }()
        case 36: try { try decoder.decodeSingularInt64Field(value: &_storage._delegatedFrozenV2BalanceForBandwidth) }()
        case 37: try { try decoder.decodeSingularInt64Field(value: &_storage._acquiredDelegatedFrozenV2BalanceForBandwidth) }()
        case 41: try { try decoder.decodeSingularInt64Field(value: &_storage._acquiredDelegatedFrozenBalanceForBandwidth) }()
        case 42: try { try decoder.decodeSingularInt64Field(value: &_storage._delegatedFrozenBalanceForBandwidth) }()
        case 46: try { try decoder.decodeSingularInt64Field(value: &_storage._oldTronPower) }()
        case 47: try { try decoder.decodeSingularMessageField(value: &_storage._tronPower) }()
        case 56: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._assetV2) }()
        case 57: try { try decoder.decodeSingularBytesField(value: &_storage._assetIssuedID) }()
        case 58: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._latestAssetOperationTimeV2) }()
        case 59: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._freeAssetNetUsageV2) }()
        case 60: try { try decoder.decodeSingularBoolField(value: &_storage._assetOptimized) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._accountName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._accountName, fieldNumber: 1)
      }
      if _storage._type != .normal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._address, fieldNumber: 3)
      }
      if _storage._balance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._balance, fieldNumber: 4)
      }
      if !_storage._votes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._votes, fieldNumber: 5)
      }
      if !_storage._asset.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._asset, fieldNumber: 6)
      }
      if !_storage._frozen.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frozen, fieldNumber: 7)
      }
      if _storage._netUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._netUsage, fieldNumber: 8)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 9)
      }
      if _storage._latestOprationTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestOprationTime, fieldNumber: 10)
      }
      if _storage._allowance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allowance, fieldNumber: 11)
      }
      if _storage._latestWithdrawTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestWithdrawTime, fieldNumber: 12)
      }
      if !_storage._code.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._code, fieldNumber: 13)
      }
      if _storage._isWitness != false {
        try visitor.visitSingularBoolField(value: _storage._isWitness, fieldNumber: 14)
      }
      if _storage._isCommittee != false {
        try visitor.visitSingularBoolField(value: _storage._isCommittee, fieldNumber: 15)
      }
      if !_storage._frozenSupply.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frozenSupply, fieldNumber: 16)
      }
      if !_storage._assetIssuedName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._assetIssuedName, fieldNumber: 17)
      }
      if !_storage._latestAssetOperationTime.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._latestAssetOperationTime, fieldNumber: 18)
      }
      if _storage._freeNetUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._freeNetUsage, fieldNumber: 19)
      }
      if !_storage._freeAssetNetUsage.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._freeAssetNetUsage, fieldNumber: 20)
      }
      if _storage._latestConsumeTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestConsumeTime, fieldNumber: 21)
      }
      if _storage._latestConsumeFreeTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestConsumeFreeTime, fieldNumber: 22)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._accountID, fieldNumber: 23)
      }
      if _storage._netWindowSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._netWindowSize, fieldNumber: 24)
      }
      try { if let v = _storage._accountResource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      if !_storage._codeHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._codeHash, fieldNumber: 30)
      }
      try { if let v = _storage._ownerPermission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._witnessPermission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      if !_storage._activePermission.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activePermission, fieldNumber: 33)
      }
      if !_storage._frozenV2.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frozenV2, fieldNumber: 34)
      }
      if !_storage._unfrozenV2.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unfrozenV2, fieldNumber: 35)
      }
      if _storage._delegatedFrozenV2BalanceForBandwidth != 0 {
        try visitor.visitSingularInt64Field(value: _storage._delegatedFrozenV2BalanceForBandwidth, fieldNumber: 36)
      }
      if _storage._acquiredDelegatedFrozenV2BalanceForBandwidth != 0 {
        try visitor.visitSingularInt64Field(value: _storage._acquiredDelegatedFrozenV2BalanceForBandwidth, fieldNumber: 37)
      }
      if _storage._acquiredDelegatedFrozenBalanceForBandwidth != 0 {
        try visitor.visitSingularInt64Field(value: _storage._acquiredDelegatedFrozenBalanceForBandwidth, fieldNumber: 41)
      }
      if _storage._delegatedFrozenBalanceForBandwidth != 0 {
        try visitor.visitSingularInt64Field(value: _storage._delegatedFrozenBalanceForBandwidth, fieldNumber: 42)
      }
      if _storage._oldTronPower != 0 {
        try visitor.visitSingularInt64Field(value: _storage._oldTronPower, fieldNumber: 46)
      }
      try { if let v = _storage._tronPower {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      } }()
      if !_storage._assetV2.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._assetV2, fieldNumber: 56)
      }
      if !_storage._assetIssuedID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._assetIssuedID, fieldNumber: 57)
      }
      if !_storage._latestAssetOperationTimeV2.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._latestAssetOperationTimeV2, fieldNumber: 58)
      }
      if !_storage._freeAssetNetUsageV2.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._freeAssetNetUsageV2, fieldNumber: 59)
      }
      if _storage._assetOptimized != false {
        try visitor.visitSingularBoolField(value: _storage._assetOptimized, fieldNumber: 60)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Account, rhs: Protocol_Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountName != rhs_storage._accountName {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._votes != rhs_storage._votes {return false}
        if _storage._asset != rhs_storage._asset {return false}
        if _storage._assetV2 != rhs_storage._assetV2 {return false}
        if _storage._frozen != rhs_storage._frozen {return false}
        if _storage._netUsage != rhs_storage._netUsage {return false}
        if _storage._acquiredDelegatedFrozenBalanceForBandwidth != rhs_storage._acquiredDelegatedFrozenBalanceForBandwidth {return false}
        if _storage._delegatedFrozenBalanceForBandwidth != rhs_storage._delegatedFrozenBalanceForBandwidth {return false}
        if _storage._oldTronPower != rhs_storage._oldTronPower {return false}
        if _storage._tronPower != rhs_storage._tronPower {return false}
        if _storage._assetOptimized != rhs_storage._assetOptimized {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._latestOprationTime != rhs_storage._latestOprationTime {return false}
        if _storage._allowance != rhs_storage._allowance {return false}
        if _storage._latestWithdrawTime != rhs_storage._latestWithdrawTime {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._isWitness != rhs_storage._isWitness {return false}
        if _storage._isCommittee != rhs_storage._isCommittee {return false}
        if _storage._frozenSupply != rhs_storage._frozenSupply {return false}
        if _storage._assetIssuedName != rhs_storage._assetIssuedName {return false}
        if _storage._assetIssuedID != rhs_storage._assetIssuedID {return false}
        if _storage._latestAssetOperationTime != rhs_storage._latestAssetOperationTime {return false}
        if _storage._latestAssetOperationTimeV2 != rhs_storage._latestAssetOperationTimeV2 {return false}
        if _storage._freeNetUsage != rhs_storage._freeNetUsage {return false}
        if _storage._freeAssetNetUsage != rhs_storage._freeAssetNetUsage {return false}
        if _storage._freeAssetNetUsageV2 != rhs_storage._freeAssetNetUsageV2 {return false}
        if _storage._latestConsumeTime != rhs_storage._latestConsumeTime {return false}
        if _storage._latestConsumeFreeTime != rhs_storage._latestConsumeFreeTime {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._netWindowSize != rhs_storage._netWindowSize {return false}
        if _storage._accountResource != rhs_storage._accountResource {return false}
        if _storage._codeHash != rhs_storage._codeHash {return false}
        if _storage._ownerPermission != rhs_storage._ownerPermission {return false}
        if _storage._witnessPermission != rhs_storage._witnessPermission {return false}
        if _storage._activePermission != rhs_storage._activePermission {return false}
        if _storage._frozenV2 != rhs_storage._frozenV2 {return false}
        if _storage._unfrozenV2 != rhs_storage._unfrozenV2 {return false}
        if _storage._delegatedFrozenV2BalanceForBandwidth != rhs_storage._delegatedFrozenV2BalanceForBandwidth {return false}
        if _storage._acquiredDelegatedFrozenV2BalanceForBandwidth != rhs_storage._acquiredDelegatedFrozenV2BalanceForBandwidth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account.Frozen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Account.protoMessageName + ".Frozen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frozen_balance"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.frozenBalance) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frozenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenBalance, fieldNumber: 1)
    }
    if self.expireTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Account.Frozen, rhs: Protocol_Account.Frozen) -> Bool {
    if lhs.frozenBalance != rhs.frozenBalance {return false}
    if lhs.expireTime != rhs.expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account.AccountResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Account.protoMessageName + ".AccountResource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_usage"),
    2: .standard(proto: "frozen_balance_for_energy"),
    3: .standard(proto: "latest_consume_time_for_energy"),
    4: .standard(proto: "acquired_delegated_frozen_balance_for_energy"),
    5: .standard(proto: "delegated_frozen_balance_for_energy"),
    6: .standard(proto: "storage_limit"),
    7: .standard(proto: "storage_usage"),
    8: .standard(proto: "latest_exchange_storage_time"),
    9: .standard(proto: "energy_window_size"),
    10: .standard(proto: "delegated_frozenV2_balance_for_energy"),
    11: .standard(proto: "acquired_delegated_frozenV2_balance_for_energy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.energyUsage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._frozenBalanceForEnergy) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.latestConsumeTimeForEnergy) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.acquiredDelegatedFrozenBalanceForEnergy) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.delegatedFrozenBalanceForEnergy) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.storageLimit) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.storageUsage) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.latestExchangeStorageTime) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.energyWindowSize) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.delegatedFrozenV2BalanceForEnergy) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.acquiredDelegatedFrozenV2BalanceForEnergy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.energyUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.energyUsage, fieldNumber: 1)
    }
    try { if let v = self._frozenBalanceForEnergy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.latestConsumeTimeForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.latestConsumeTimeForEnergy, fieldNumber: 3)
    }
    if self.acquiredDelegatedFrozenBalanceForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.acquiredDelegatedFrozenBalanceForEnergy, fieldNumber: 4)
    }
    if self.delegatedFrozenBalanceForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.delegatedFrozenBalanceForEnergy, fieldNumber: 5)
    }
    if self.storageLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.storageLimit, fieldNumber: 6)
    }
    if self.storageUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.storageUsage, fieldNumber: 7)
    }
    if self.latestExchangeStorageTime != 0 {
      try visitor.visitSingularInt64Field(value: self.latestExchangeStorageTime, fieldNumber: 8)
    }
    if self.energyWindowSize != 0 {
      try visitor.visitSingularInt64Field(value: self.energyWindowSize, fieldNumber: 9)
    }
    if self.delegatedFrozenV2BalanceForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.delegatedFrozenV2BalanceForEnergy, fieldNumber: 10)
    }
    if self.acquiredDelegatedFrozenV2BalanceForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.acquiredDelegatedFrozenV2BalanceForEnergy, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Account.AccountResource, rhs: Protocol_Account.AccountResource) -> Bool {
    if lhs.energyUsage != rhs.energyUsage {return false}
    if lhs._frozenBalanceForEnergy != rhs._frozenBalanceForEnergy {return false}
    if lhs.latestConsumeTimeForEnergy != rhs.latestConsumeTimeForEnergy {return false}
    if lhs.acquiredDelegatedFrozenBalanceForEnergy != rhs.acquiredDelegatedFrozenBalanceForEnergy {return false}
    if lhs.delegatedFrozenBalanceForEnergy != rhs.delegatedFrozenBalanceForEnergy {return false}
    if lhs.storageLimit != rhs.storageLimit {return false}
    if lhs.storageUsage != rhs.storageUsage {return false}
    if lhs.latestExchangeStorageTime != rhs.latestExchangeStorageTime {return false}
    if lhs.energyWindowSize != rhs.energyWindowSize {return false}
    if lhs.delegatedFrozenV2BalanceForEnergy != rhs.delegatedFrozenV2BalanceForEnergy {return false}
    if lhs.acquiredDelegatedFrozenV2BalanceForEnergy != rhs.acquiredDelegatedFrozenV2BalanceForEnergy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account.FreezeV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Account.protoMessageName + ".FreezeV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .bandwidth {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Account.FreezeV2, rhs: Protocol_Account.FreezeV2) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account.UnFreezeV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Account.protoMessageName + ".UnFreezeV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    3: .standard(proto: "unfreeze_amount"),
    4: .standard(proto: "unfreeze_expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.unfreezeAmount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.unfreezeExpireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .bandwidth {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.unfreezeAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.unfreezeAmount, fieldNumber: 3)
    }
    if self.unfreezeExpireTime != 0 {
      try visitor.visitSingularInt64Field(value: self.unfreezeExpireTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Account.UnFreezeV2, rhs: Protocol_Account.UnFreezeV2) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unfreezeAmount != rhs.unfreezeAmount {return false}
    if lhs.unfreezeExpireTime != rhs.unfreezeExpireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "weight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.weight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.weight != 0 {
      try visitor.visitSingularInt64Field(value: self.weight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Key, rhs: Protocol_Key) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DelegatedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatedResource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .standard(proto: "frozen_balance_for_bandwidth"),
    4: .standard(proto: "frozen_balance_for_energy"),
    5: .standard(proto: "expire_time_for_bandwidth"),
    6: .standard(proto: "expire_time_for_energy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.frozenBalanceForBandwidth) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.frozenBalanceForEnergy) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.expireTimeForBandwidth) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.expireTimeForEnergy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularBytesField(value: self.to, fieldNumber: 2)
    }
    if self.frozenBalanceForBandwidth != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenBalanceForBandwidth, fieldNumber: 3)
    }
    if self.frozenBalanceForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenBalanceForEnergy, fieldNumber: 4)
    }
    if self.expireTimeForBandwidth != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTimeForBandwidth, fieldNumber: 5)
    }
    if self.expireTimeForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTimeForEnergy, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DelegatedResource, rhs: Protocol_DelegatedResource) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.frozenBalanceForBandwidth != rhs.frozenBalanceForBandwidth {return false}
    if lhs.frozenBalanceForEnergy != rhs.frozenBalanceForEnergy {return false}
    if lhs.expireTimeForBandwidth != rhs.expireTimeForBandwidth {return false}
    if lhs.expireTimeForEnergy != rhs.expireTimeForEnergy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_authority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".authority"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "permission_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.permissionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.permissionName.isEmpty {
      try visitor.visitSingularBytesField(value: self.permissionName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_authority, rhs: Protocol_authority) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.permissionName != rhs.permissionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Permission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "permission_name"),
    4: .same(proto: "threshold"),
    5: .standard(proto: "parent_id"),
    6: .same(proto: "operations"),
    7: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.permissionName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.threshold) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.parentID) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.operations) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .owner {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 2)
    }
    if !self.permissionName.isEmpty {
      try visitor.visitSingularStringField(value: self.permissionName, fieldNumber: 3)
    }
    if self.threshold != 0 {
      try visitor.visitSingularInt64Field(value: self.threshold, fieldNumber: 4)
    }
    if self.parentID != 0 {
      try visitor.visitSingularInt32Field(value: self.parentID, fieldNumber: 5)
    }
    if !self.operations.isEmpty {
      try visitor.visitSingularBytesField(value: self.operations, fieldNumber: 6)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Permission, rhs: Protocol_Permission) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.permissionName != rhs.permissionName {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.parentID != rhs.parentID {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Permission.PermissionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Owner"),
    1: .same(proto: "Witness"),
    2: .same(proto: "Active"),
  ]
}

extension Protocol_Witness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Witness"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "voteCount"),
    3: .same(proto: "pubKey"),
    4: .same(proto: "url"),
    5: .same(proto: "totalProduced"),
    6: .same(proto: "totalMissed"),
    7: .same(proto: "latestBlockNum"),
    8: .same(proto: "latestSlotNum"),
    9: .same(proto: "isJobs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.voteCount) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pubKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalProduced) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalMissed) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.latestBlockNum) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.latestSlotNum) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isJobs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.voteCount != 0 {
      try visitor.visitSingularInt64Field(value: self.voteCount, fieldNumber: 2)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if self.totalProduced != 0 {
      try visitor.visitSingularInt64Field(value: self.totalProduced, fieldNumber: 5)
    }
    if self.totalMissed != 0 {
      try visitor.visitSingularInt64Field(value: self.totalMissed, fieldNumber: 6)
    }
    if self.latestBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.latestBlockNum, fieldNumber: 7)
    }
    if self.latestSlotNum != 0 {
      try visitor.visitSingularInt64Field(value: self.latestSlotNum, fieldNumber: 8)
    }
    if self.isJobs != false {
      try visitor.visitSingularBoolField(value: self.isJobs, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Witness, rhs: Protocol_Witness) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.voteCount != rhs.voteCount {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.url != rhs.url {return false}
    if lhs.totalProduced != rhs.totalProduced {return false}
    if lhs.totalMissed != rhs.totalMissed {return false}
    if lhs.latestBlockNum != rhs.latestBlockNum {return false}
    if lhs.latestSlotNum != rhs.latestSlotNum {return false}
    if lhs.isJobs != rhs.isJobs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Votes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Votes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "old_votes"),
    3: .standard(proto: "new_votes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.oldVotes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.newVotes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.oldVotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldVotes, fieldNumber: 2)
    }
    if !self.newVotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newVotes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Votes, rhs: Protocol_Votes) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.oldVotes != rhs.oldVotes {return false}
    if lhs.newVotes != rhs.newVotes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TXOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "pubKeyHash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pubKeyHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    if !self.pubKeyHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKeyHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TXOutput, rhs: Protocol_TXOutput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.pubKeyHash != rhs.pubKeyHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TXInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawData) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TXInput, rhs: Protocol_TXInput) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXInput.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_TXInput.protoMessageName + ".raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txID"),
    2: .same(proto: "vout"),
    3: .same(proto: "pubKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.vout) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pubKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if self.vout != 0 {
      try visitor.visitSingularInt64Field(value: self.vout, fieldNumber: 2)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TXInput.raw, rhs: Protocol_TXInput.raw) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.vout != rhs.vout {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TXOutputs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TXOutputs, rhs: Protocol_TXOutputs) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ResourceReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_usage"),
    2: .standard(proto: "energy_fee"),
    3: .standard(proto: "origin_energy_usage"),
    4: .standard(proto: "energy_usage_total"),
    5: .standard(proto: "net_usage"),
    6: .standard(proto: "net_fee"),
    7: .same(proto: "result"),
    8: .standard(proto: "energy_penalty_total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.energyUsage) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.energyFee) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.originEnergyUsage) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.energyUsageTotal) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.netUsage) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.netFee) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.energyPenaltyTotal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.energyUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.energyUsage, fieldNumber: 1)
    }
    if self.energyFee != 0 {
      try visitor.visitSingularInt64Field(value: self.energyFee, fieldNumber: 2)
    }
    if self.originEnergyUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.originEnergyUsage, fieldNumber: 3)
    }
    if self.energyUsageTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.energyUsageTotal, fieldNumber: 4)
    }
    if self.netUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.netUsage, fieldNumber: 5)
    }
    if self.netFee != 0 {
      try visitor.visitSingularInt64Field(value: self.netFee, fieldNumber: 6)
    }
    if self.result != .default {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 7)
    }
    if self.energyPenaltyTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.energyPenaltyTotal, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ResourceReceipt, rhs: Protocol_ResourceReceipt) -> Bool {
    if lhs.energyUsage != rhs.energyUsage {return false}
    if lhs.energyFee != rhs.energyFee {return false}
    if lhs.originEnergyUsage != rhs.originEnergyUsage {return false}
    if lhs.energyUsageTotal != rhs.energyUsageTotal {return false}
    if lhs.netUsage != rhs.netUsage {return false}
    if lhs.netFee != rhs.netFee {return false}
    if lhs.result != rhs.result {return false}
    if lhs.energyPenaltyTotal != rhs.energyPenaltyTotal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketOrderDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketOrderDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "makerOrderId"),
    2: .same(proto: "takerOrderId"),
    3: .same(proto: "fillSellQuantity"),
    4: .same(proto: "fillBuyQuantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.makerOrderID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.takerOrderID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fillSellQuantity) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.fillBuyQuantity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.makerOrderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.makerOrderID, fieldNumber: 1)
    }
    if !self.takerOrderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.takerOrderID, fieldNumber: 2)
    }
    if self.fillSellQuantity != 0 {
      try visitor.visitSingularInt64Field(value: self.fillSellQuantity, fieldNumber: 3)
    }
    if self.fillBuyQuantity != 0 {
      try visitor.visitSingularInt64Field(value: self.fillBuyQuantity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MarketOrderDetail, rhs: Protocol_MarketOrderDetail) -> Bool {
    if lhs.makerOrderID != rhs.makerOrderID {return false}
    if lhs.takerOrderID != rhs.takerOrderID {return false}
    if lhs.fillSellQuantity != rhs.fillSellQuantity {return false}
    if lhs.fillBuyQuantity != rhs.fillBuyQuantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .same(proto: "signature"),
    5: .same(proto: "ret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawData) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.signature) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.ret) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signature.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signature, fieldNumber: 2)
    }
    if !self.ret.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ret, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transaction, rhs: Protocol_Transaction) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.ret != rhs.ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Contract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Contract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameter"),
    3: .same(proto: "provider"),
    4: .same(proto: "ContractName"),
    5: .standard(proto: "Permission_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.provider) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.contractName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.permissionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .accountCreateContract {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.provider.isEmpty {
      try visitor.visitSingularBytesField(value: self.provider, fieldNumber: 3)
    }
    if !self.contractName.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractName, fieldNumber: 4)
    }
    if self.permissionID != 0 {
      try visitor.visitSingularInt32Field(value: self.permissionID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transaction.Contract, rhs: Protocol_Transaction.Contract) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.contractName != rhs.contractName {return false}
    if lhs.permissionID != rhs.permissionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Contract.ContractType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AccountCreateContract"),
    1: .same(proto: "TransferContract"),
    2: .same(proto: "TransferAssetContract"),
    3: .same(proto: "VoteAssetContract"),
    4: .same(proto: "VoteWitnessContract"),
    5: .same(proto: "WitnessCreateContract"),
    6: .same(proto: "AssetIssueContract"),
    8: .same(proto: "WitnessUpdateContract"),
    9: .same(proto: "ParticipateAssetIssueContract"),
    10: .same(proto: "AccountUpdateContract"),
    11: .same(proto: "FreezeBalanceContract"),
    12: .same(proto: "UnfreezeBalanceContract"),
    13: .same(proto: "WithdrawBalanceContract"),
    14: .same(proto: "UnfreezeAssetContract"),
    15: .same(proto: "UpdateAssetContract"),
    16: .same(proto: "ProposalCreateContract"),
    17: .same(proto: "ProposalApproveContract"),
    18: .same(proto: "ProposalDeleteContract"),
    19: .same(proto: "SetAccountIdContract"),
    20: .same(proto: "CustomContract"),
    30: .same(proto: "CreateSmartContract"),
    31: .same(proto: "TriggerSmartContract"),
    32: .same(proto: "GetContract"),
    33: .same(proto: "UpdateSettingContract"),
    41: .same(proto: "ExchangeCreateContract"),
    42: .same(proto: "ExchangeInjectContract"),
    43: .same(proto: "ExchangeWithdrawContract"),
    44: .same(proto: "ExchangeTransactionContract"),
    45: .same(proto: "UpdateEnergyLimitContract"),
    46: .same(proto: "AccountPermissionUpdateContract"),
    48: .same(proto: "ClearABIContract"),
    49: .same(proto: "UpdateBrokerageContract"),
    51: .same(proto: "ShieldedTransferContract"),
    52: .same(proto: "MarketSellAssetContract"),
    53: .same(proto: "MarketCancelOrderContract"),
    54: .same(proto: "FreezeBalanceV2Contract"),
    55: .same(proto: "UnfreezeBalanceV2Contract"),
    56: .same(proto: "WithdrawExpireUnfreezeContract"),
    57: .same(proto: "DelegateResourceContract"),
    58: .same(proto: "UnDelegateResourceContract"),
  ]
}

extension Protocol_Transaction.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fee"),
    2: .same(proto: "ret"),
    3: .same(proto: "contractRet"),
    14: .same(proto: "assetIssueID"),
    15: .standard(proto: "withdraw_amount"),
    16: .standard(proto: "unfreeze_amount"),
    18: .standard(proto: "exchange_received_amount"),
    19: .standard(proto: "exchange_inject_another_amount"),
    20: .standard(proto: "exchange_withdraw_another_amount"),
    21: .standard(proto: "exchange_id"),
    22: .standard(proto: "shielded_transaction_fee"),
    25: .same(proto: "orderId"),
    26: .same(proto: "orderDetails"),
    27: .standard(proto: "withdraw_expire_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.fee) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.ret) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.contractRet) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.assetIssueID) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.withdrawAmount) }()
      case 16: try { try decoder.decodeSingularInt64Field(value: &self.unfreezeAmount) }()
      case 18: try { try decoder.decodeSingularInt64Field(value: &self.exchangeReceivedAmount) }()
      case 19: try { try decoder.decodeSingularInt64Field(value: &self.exchangeInjectAnotherAmount) }()
      case 20: try { try decoder.decodeSingularInt64Field(value: &self.exchangeWithdrawAnotherAmount) }()
      case 21: try { try decoder.decodeSingularInt64Field(value: &self.exchangeID) }()
      case 22: try { try decoder.decodeSingularInt64Field(value: &self.shieldedTransactionFee) }()
      case 25: try { try decoder.decodeSingularBytesField(value: &self.orderID) }()
      case 26: try { try decoder.decodeRepeatedMessageField(value: &self.orderDetails) }()
      case 27: try { try decoder.decodeSingularInt64Field(value: &self.withdrawExpireAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 1)
    }
    if self.ret != .sucess {
      try visitor.visitSingularEnumField(value: self.ret, fieldNumber: 2)
    }
    if self.contractRet != .default {
      try visitor.visitSingularEnumField(value: self.contractRet, fieldNumber: 3)
    }
    if !self.assetIssueID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetIssueID, fieldNumber: 14)
    }
    if self.withdrawAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.withdrawAmount, fieldNumber: 15)
    }
    if self.unfreezeAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.unfreezeAmount, fieldNumber: 16)
    }
    if self.exchangeReceivedAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeReceivedAmount, fieldNumber: 18)
    }
    if self.exchangeInjectAnotherAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeInjectAnotherAmount, fieldNumber: 19)
    }
    if self.exchangeWithdrawAnotherAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeWithdrawAnotherAmount, fieldNumber: 20)
    }
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 21)
    }
    if self.shieldedTransactionFee != 0 {
      try visitor.visitSingularInt64Field(value: self.shieldedTransactionFee, fieldNumber: 22)
    }
    if !self.orderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderID, fieldNumber: 25)
    }
    if !self.orderDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderDetails, fieldNumber: 26)
    }
    if self.withdrawExpireAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.withdrawExpireAmount, fieldNumber: 27)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transaction.Result, rhs: Protocol_Transaction.Result) -> Bool {
    if lhs.fee != rhs.fee {return false}
    if lhs.ret != rhs.ret {return false}
    if lhs.contractRet != rhs.contractRet {return false}
    if lhs.assetIssueID != rhs.assetIssueID {return false}
    if lhs.withdrawAmount != rhs.withdrawAmount {return false}
    if lhs.unfreezeAmount != rhs.unfreezeAmount {return false}
    if lhs.exchangeReceivedAmount != rhs.exchangeReceivedAmount {return false}
    if lhs.exchangeInjectAnotherAmount != rhs.exchangeInjectAnotherAmount {return false}
    if lhs.exchangeWithdrawAnotherAmount != rhs.exchangeWithdrawAnotherAmount {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.shieldedTransactionFee != rhs.shieldedTransactionFee {return false}
    if lhs.orderID != rhs.orderID {return false}
    if lhs.orderDetails != rhs.orderDetails {return false}
    if lhs.withdrawExpireAmount != rhs.withdrawExpireAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Result.code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension Protocol_Transaction.Result.contractResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "REVERT"),
    3: .same(proto: "BAD_JUMP_DESTINATION"),
    4: .same(proto: "OUT_OF_MEMORY"),
    5: .same(proto: "PRECOMPILED_CONTRACT"),
    6: .same(proto: "STACK_TOO_SMALL"),
    7: .same(proto: "STACK_TOO_LARGE"),
    8: .same(proto: "ILLEGAL_OPERATION"),
    9: .same(proto: "STACK_OVERFLOW"),
    10: .same(proto: "OUT_OF_ENERGY"),
    11: .same(proto: "OUT_OF_TIME"),
    12: .same(proto: "JVM_STACK_OVER_FLOW"),
    13: .same(proto: "UNKNOWN"),
    14: .same(proto: "TRANSFER_FAILED"),
    15: .same(proto: "INVALID_CODE"),
  ]
}

extension Protocol_Transaction.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ref_block_bytes"),
    3: .standard(proto: "ref_block_num"),
    4: .standard(proto: "ref_block_hash"),
    8: .same(proto: "expiration"),
    9: .same(proto: "auths"),
    10: .same(proto: "data"),
    11: .same(proto: "contract"),
    12: .same(proto: "scripts"),
    14: .same(proto: "timestamp"),
    18: .standard(proto: "fee_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.refBlockBytes) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.refBlockNum) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.refBlockHash) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.expiration) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.auths) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.contract) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.scripts) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 18: try { try decoder.decodeSingularInt64Field(value: &self.feeLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refBlockBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockBytes, fieldNumber: 1)
    }
    if self.refBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.refBlockNum, fieldNumber: 3)
    }
    if !self.refBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockHash, fieldNumber: 4)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 8)
    }
    if !self.auths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auths, fieldNumber: 9)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 10)
    }
    if !self.contract.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contract, fieldNumber: 11)
    }
    if !self.scripts.isEmpty {
      try visitor.visitSingularBytesField(value: self.scripts, fieldNumber: 12)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 14)
    }
    if self.feeLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.feeLimit, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transaction.raw, rhs: Protocol_Transaction.raw) -> Bool {
    if lhs.refBlockBytes != rhs.refBlockBytes {return false}
    if lhs.refBlockNum != rhs.refBlockNum {return false}
    if lhs.refBlockHash != rhs.refBlockHash {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.auths != rhs.auths {return false}
    if lhs.data != rhs.data {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.scripts != rhs.scripts {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "fee"),
    3: .same(proto: "blockNumber"),
    4: .same(proto: "blockTimeStamp"),
    5: .same(proto: "contractResult"),
    6: .standard(proto: "contract_address"),
    7: .same(proto: "receipt"),
    8: .same(proto: "log"),
    9: .same(proto: "result"),
    10: .same(proto: "resMessage"),
    14: .same(proto: "assetIssueID"),
    15: .standard(proto: "withdraw_amount"),
    16: .standard(proto: "unfreeze_amount"),
    17: .standard(proto: "internal_transactions"),
    18: .standard(proto: "exchange_received_amount"),
    19: .standard(proto: "exchange_inject_another_amount"),
    20: .standard(proto: "exchange_withdraw_another_amount"),
    21: .standard(proto: "exchange_id"),
    22: .standard(proto: "shielded_transaction_fee"),
    25: .same(proto: "orderId"),
    26: .same(proto: "orderDetails"),
    27: .same(proto: "packingFee"),
    28: .standard(proto: "withdraw_expire_amount"),
  ]

  fileprivate class _StorageClass {
    var _id: Data = Data()
    var _fee: Int64 = 0
    var _blockNumber: Int64 = 0
    var _blockTimeStamp: Int64 = 0
    var _contractResult: [Data] = []
    var _contractAddress: Data = Data()
    var _receipt: Protocol_ResourceReceipt? = nil
    var _log: [Protocol_TransactionInfo.Log] = []
    var _result: Protocol_TransactionInfo.code = .sucess
    var _resMessage: Data = Data()
    var _assetIssueID: String = String()
    var _withdrawAmount: Int64 = 0
    var _unfreezeAmount: Int64 = 0
    var _internalTransactions: [Protocol_InternalTransaction] = []
    var _exchangeReceivedAmount: Int64 = 0
    var _exchangeInjectAnotherAmount: Int64 = 0
    var _exchangeWithdrawAnotherAmount: Int64 = 0
    var _exchangeID: Int64 = 0
    var _shieldedTransactionFee: Int64 = 0
    var _orderID: Data = Data()
    var _orderDetails: [Protocol_MarketOrderDetail] = []
    var _packingFee: Int64 = 0
    var _withdrawExpireAmount: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fee = source._fee
      _blockNumber = source._blockNumber
      _blockTimeStamp = source._blockTimeStamp
      _contractResult = source._contractResult
      _contractAddress = source._contractAddress
      _receipt = source._receipt
      _log = source._log
      _result = source._result
      _resMessage = source._resMessage
      _assetIssueID = source._assetIssueID
      _withdrawAmount = source._withdrawAmount
      _unfreezeAmount = source._unfreezeAmount
      _internalTransactions = source._internalTransactions
      _exchangeReceivedAmount = source._exchangeReceivedAmount
      _exchangeInjectAnotherAmount = source._exchangeInjectAnotherAmount
      _exchangeWithdrawAnotherAmount = source._exchangeWithdrawAnotherAmount
      _exchangeID = source._exchangeID
      _shieldedTransactionFee = source._shieldedTransactionFee
      _orderID = source._orderID
      _orderDetails = source._orderDetails
      _packingFee = source._packingFee
      _withdrawExpireAmount = source._withdrawExpireAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._fee) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._blockNumber) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._blockTimeStamp) }()
        case 5: try { try decoder.decodeRepeatedBytesField(value: &_storage._contractResult) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._contractAddress) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._receipt) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._log) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._result) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._resMessage) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._assetIssueID) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._withdrawAmount) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._unfreezeAmount) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._internalTransactions) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._exchangeReceivedAmount) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._exchangeInjectAnotherAmount) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._exchangeWithdrawAnotherAmount) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._exchangeID) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._shieldedTransactionFee) }()
        case 25: try { try decoder.decodeSingularBytesField(value: &_storage._orderID) }()
        case 26: try { try decoder.decodeRepeatedMessageField(value: &_storage._orderDetails) }()
        case 27: try { try decoder.decodeSingularInt64Field(value: &_storage._packingFee) }()
        case 28: try { try decoder.decodeSingularInt64Field(value: &_storage._withdrawExpireAmount) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._fee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fee, fieldNumber: 2)
      }
      if _storage._blockNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockNumber, fieldNumber: 3)
      }
      if _storage._blockTimeStamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockTimeStamp, fieldNumber: 4)
      }
      if !_storage._contractResult.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._contractResult, fieldNumber: 5)
      }
      if !_storage._contractAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._contractAddress, fieldNumber: 6)
      }
      try { if let v = _storage._receipt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._log.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._log, fieldNumber: 8)
      }
      if _storage._result != .sucess {
        try visitor.visitSingularEnumField(value: _storage._result, fieldNumber: 9)
      }
      if !_storage._resMessage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._resMessage, fieldNumber: 10)
      }
      if !_storage._assetIssueID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetIssueID, fieldNumber: 14)
      }
      if _storage._withdrawAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._withdrawAmount, fieldNumber: 15)
      }
      if _storage._unfreezeAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unfreezeAmount, fieldNumber: 16)
      }
      if !_storage._internalTransactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._internalTransactions, fieldNumber: 17)
      }
      if _storage._exchangeReceivedAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exchangeReceivedAmount, fieldNumber: 18)
      }
      if _storage._exchangeInjectAnotherAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exchangeInjectAnotherAmount, fieldNumber: 19)
      }
      if _storage._exchangeWithdrawAnotherAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exchangeWithdrawAnotherAmount, fieldNumber: 20)
      }
      if _storage._exchangeID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exchangeID, fieldNumber: 21)
      }
      if _storage._shieldedTransactionFee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._shieldedTransactionFee, fieldNumber: 22)
      }
      if !_storage._orderID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._orderID, fieldNumber: 25)
      }
      if !_storage._orderDetails.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._orderDetails, fieldNumber: 26)
      }
      if _storage._packingFee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._packingFee, fieldNumber: 27)
      }
      if _storage._withdrawExpireAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._withdrawExpireAmount, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionInfo, rhs: Protocol_TransactionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fee != rhs_storage._fee {return false}
        if _storage._blockNumber != rhs_storage._blockNumber {return false}
        if _storage._blockTimeStamp != rhs_storage._blockTimeStamp {return false}
        if _storage._contractResult != rhs_storage._contractResult {return false}
        if _storage._contractAddress != rhs_storage._contractAddress {return false}
        if _storage._receipt != rhs_storage._receipt {return false}
        if _storage._log != rhs_storage._log {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._resMessage != rhs_storage._resMessage {return false}
        if _storage._assetIssueID != rhs_storage._assetIssueID {return false}
        if _storage._withdrawAmount != rhs_storage._withdrawAmount {return false}
        if _storage._unfreezeAmount != rhs_storage._unfreezeAmount {return false}
        if _storage._internalTransactions != rhs_storage._internalTransactions {return false}
        if _storage._exchangeReceivedAmount != rhs_storage._exchangeReceivedAmount {return false}
        if _storage._exchangeInjectAnotherAmount != rhs_storage._exchangeInjectAnotherAmount {return false}
        if _storage._exchangeWithdrawAnotherAmount != rhs_storage._exchangeWithdrawAnotherAmount {return false}
        if _storage._exchangeID != rhs_storage._exchangeID {return false}
        if _storage._shieldedTransactionFee != rhs_storage._shieldedTransactionFee {return false}
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._orderDetails != rhs_storage._orderDetails {return false}
        if _storage._packingFee != rhs_storage._packingFee {return false}
        if _storage._withdrawExpireAmount != rhs_storage._withdrawExpireAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionInfo.code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension Protocol_TransactionInfo.Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_TransactionInfo.protoMessageName + ".Log"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "topics"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.topics) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.topics.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.topics, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionInfo.Log, rhs: Protocol_TransactionInfo.Log) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionRet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionRet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockNumber"),
    2: .same(proto: "blockTimeStamp"),
    3: .same(proto: "transactioninfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.blockNumber) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blockTimeStamp) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transactioninfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.blockNumber, fieldNumber: 1)
    }
    if self.blockTimeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.blockTimeStamp, fieldNumber: 2)
    }
    if !self.transactioninfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactioninfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionRet, rhs: Protocol_TransactionRet) -> Bool {
    if lhs.blockNumber != rhs.blockNumber {return false}
    if lhs.blockTimeStamp != rhs.blockTimeStamp {return false}
    if lhs.transactioninfo != rhs.transactioninfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transactions, rhs: Protocol_Transactions) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionSign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionSign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "privateKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionSign, rhs: Protocol_TransactionSign) -> Bool {
    if lhs._transaction != rhs._transaction {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .standard(proto: "witness_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawData) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.witnessSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.witnessSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessSignature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockHeader, rhs: Protocol_BlockHeader) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.witnessSignature != rhs.witnessSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockHeader.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_BlockHeader.protoMessageName + ".raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "txTrieRoot"),
    3: .same(proto: "parentHash"),
    7: .same(proto: "number"),
    8: .standard(proto: "witness_id"),
    9: .standard(proto: "witness_address"),
    10: .same(proto: "version"),
    11: .same(proto: "accountStateRoot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txTrieRoot) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.parentHash) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.number) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.witnessID) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.witnessAddress) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.accountStateRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.txTrieRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.txTrieRoot, fieldNumber: 2)
    }
    if !self.parentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.parentHash, fieldNumber: 3)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 7)
    }
    if self.witnessID != 0 {
      try visitor.visitSingularInt64Field(value: self.witnessID, fieldNumber: 8)
    }
    if !self.witnessAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessAddress, fieldNumber: 9)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 10)
    }
    if !self.accountStateRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.accountStateRoot, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockHeader.raw, rhs: Protocol_BlockHeader.raw) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.txTrieRoot != rhs.txTrieRoot {return false}
    if lhs.parentHash != rhs.parentHash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.witnessID != rhs.witnessID {return false}
    if lhs.witnessAddress != rhs.witnessAddress {return false}
    if lhs.version != rhs.version {return false}
    if lhs.accountStateRoot != rhs.accountStateRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "block_header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockHeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try { if let v = self._blockHeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Block, rhs: Protocol_Block) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs._blockHeader != rhs._blockHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainInventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainInventory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .standard(proto: "remain_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.remainNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    if self.remainNum != 0 {
      try visitor.visitSingularInt64Field(value: self.remainNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ChainInventory, rhs: Protocol_ChainInventory) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.remainNum != rhs.remainNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainInventory.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_ChainInventory.protoMessageName + ".BlockId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.number) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ChainInventory.BlockId, rhs: Protocol_ChainInventory.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockInventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockInventory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    if self.type != .sync {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockInventory, rhs: Protocol_BlockInventory) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockInventory.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC"),
    1: .same(proto: "ADVTISE"),
    2: .same(proto: "FETCH"),
  ]
}

extension Protocol_BlockInventory.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_BlockInventory.protoMessageName + ".BlockId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.number) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockInventory.BlockId, rhs: Protocol_BlockInventory.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Inventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Inventory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .trx {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Inventory, rhs: Protocol_Inventory) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Inventory.InventoryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRX"),
    1: .same(proto: "BLOCK"),
  ]
}

extension Protocol_Items: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Items"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "blocks"),
    3: .standard(proto: "block_headers"),
    4: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blockHeaders) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .err {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 2)
    }
    if !self.blockHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockHeaders, fieldNumber: 3)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Items, rhs: Protocol_Items) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.blockHeaders != rhs.blockHeaders {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Items.ItemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERR"),
    1: .same(proto: "TRX"),
    2: .same(proto: "BLOCK"),
    3: .same(proto: "BLOCKHEADER"),
  ]
}

extension Protocol_DynamicProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DynamicProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_solidity_block_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.lastSolidityBlockNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastSolidityBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSolidityBlockNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DynamicProperties, rhs: Protocol_DynamicProperties) -> Bool {
    if lhs.lastSolidityBlockNum != rhs.lastSolidityBlockNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DisconnectMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .requested {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DisconnectMessage, rhs: Protocol_DisconnectMessage) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_HelloMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HelloMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "version"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "genesisBlockId"),
    5: .same(proto: "solidBlockId"),
    6: .same(proto: "headBlockId"),
    7: .same(proto: "address"),
    8: .same(proto: "signature"),
    9: .same(proto: "nodeType"),
    10: .same(proto: "lowestBlockNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._genesisBlockID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._solidBlockID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._headBlockID) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.nodeType) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.lowestBlockNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try { if let v = self._genesisBlockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._solidBlockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._headBlockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 7)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 8)
    }
    if self.nodeType != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeType, fieldNumber: 9)
    }
    if self.lowestBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.lowestBlockNum, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_HelloMessage, rhs: Protocol_HelloMessage) -> Bool {
    if lhs._from != rhs._from {return false}
    if lhs.version != rhs.version {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._genesisBlockID != rhs._genesisBlockID {return false}
    if lhs._solidBlockID != rhs._solidBlockID {return false}
    if lhs._headBlockID != rhs._headBlockID {return false}
    if lhs.address != rhs.address {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.nodeType != rhs.nodeType {return false}
    if lhs.lowestBlockNum != rhs.lowestBlockNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_HelloMessage.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_HelloMessage.protoMessageName + ".BlockId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.number) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_HelloMessage.BlockId, rhs: Protocol_HelloMessage.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_InternalTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InternalTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "caller_address"),
    3: .standard(proto: "transferTo_address"),
    4: .same(proto: "callValueInfo"),
    5: .same(proto: "note"),
    6: .same(proto: "rejected"),
    7: .same(proto: "extra"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.callerAddress) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.transferToAddress) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.callValueInfo) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.note) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.rejected) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.extra) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.callerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.callerAddress, fieldNumber: 2)
    }
    if !self.transferToAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transferToAddress, fieldNumber: 3)
    }
    if !self.callValueInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.callValueInfo, fieldNumber: 4)
    }
    if !self.note.isEmpty {
      try visitor.visitSingularBytesField(value: self.note, fieldNumber: 5)
    }
    if self.rejected != false {
      try visitor.visitSingularBoolField(value: self.rejected, fieldNumber: 6)
    }
    if !self.extra.isEmpty {
      try visitor.visitSingularStringField(value: self.extra, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_InternalTransaction, rhs: Protocol_InternalTransaction) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.callerAddress != rhs.callerAddress {return false}
    if lhs.transferToAddress != rhs.transferToAddress {return false}
    if lhs.callValueInfo != rhs.callValueInfo {return false}
    if lhs.note != rhs.note {return false}
    if lhs.rejected != rhs.rejected {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_InternalTransaction.CallValueInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_InternalTransaction.protoMessageName + ".CallValueInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callValue"),
    2: .same(proto: "tokenId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.callValue) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.callValue != 0 {
      try visitor.visitSingularInt64Field(value: self.callValue, fieldNumber: 1)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_InternalTransaction.CallValueInfo, rhs: Protocol_InternalTransaction.CallValueInfo) -> Bool {
    if lhs.callValue != rhs.callValue {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DelegatedResourceAccountIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatedResourceAccountIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "fromAccounts"),
    3: .same(proto: "toAccounts"),
    4: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.account) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.fromAccounts) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.toAccounts) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularBytesField(value: self.account, fieldNumber: 1)
    }
    if !self.fromAccounts.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.fromAccounts, fieldNumber: 2)
    }
    if !self.toAccounts.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.toAccounts, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DelegatedResourceAccountIndex, rhs: Protocol_DelegatedResourceAccountIndex) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.fromAccounts != rhs.fromAccounts {return false}
    if lhs.toAccounts != rhs.toAccounts {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beginSyncNum"),
    2: .same(proto: "block"),
    3: .same(proto: "solidityBlock"),
    4: .same(proto: "currentConnectCount"),
    5: .same(proto: "activeConnectCount"),
    6: .same(proto: "passiveConnectCount"),
    7: .same(proto: "totalFlow"),
    8: .same(proto: "peerInfoList"),
    9: .same(proto: "configNodeInfo"),
    10: .same(proto: "machineInfo"),
    11: .same(proto: "cheatWitnessInfoMap"),
  ]

  fileprivate class _StorageClass {
    var _beginSyncNum: Int64 = 0
    var _block: String = String()
    var _solidityBlock: String = String()
    var _currentConnectCount: Int32 = 0
    var _activeConnectCount: Int32 = 0
    var _passiveConnectCount: Int32 = 0
    var _totalFlow: Int64 = 0
    var _peerInfoList: [Protocol_NodeInfo.PeerInfo] = []
    var _configNodeInfo: Protocol_NodeInfo.ConfigNodeInfo? = nil
    var _machineInfo: Protocol_NodeInfo.MachineInfo? = nil
    var _cheatWitnessInfoMap: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _beginSyncNum = source._beginSyncNum
      _block = source._block
      _solidityBlock = source._solidityBlock
      _currentConnectCount = source._currentConnectCount
      _activeConnectCount = source._activeConnectCount
      _passiveConnectCount = source._passiveConnectCount
      _totalFlow = source._totalFlow
      _peerInfoList = source._peerInfoList
      _configNodeInfo = source._configNodeInfo
      _machineInfo = source._machineInfo
      _cheatWitnessInfoMap = source._cheatWitnessInfoMap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._beginSyncNum) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._block) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._solidityBlock) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._currentConnectCount) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._activeConnectCount) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._passiveConnectCount) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._totalFlow) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._peerInfoList) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._configNodeInfo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._machineInfo) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._cheatWitnessInfoMap) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._beginSyncNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._beginSyncNum, fieldNumber: 1)
      }
      if !_storage._block.isEmpty {
        try visitor.visitSingularStringField(value: _storage._block, fieldNumber: 2)
      }
      if !_storage._solidityBlock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._solidityBlock, fieldNumber: 3)
      }
      if _storage._currentConnectCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentConnectCount, fieldNumber: 4)
      }
      if _storage._activeConnectCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._activeConnectCount, fieldNumber: 5)
      }
      if _storage._passiveConnectCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._passiveConnectCount, fieldNumber: 6)
      }
      if _storage._totalFlow != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalFlow, fieldNumber: 7)
      }
      if !_storage._peerInfoList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._peerInfoList, fieldNumber: 8)
      }
      try { if let v = _storage._configNodeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._machineInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._cheatWitnessInfoMap.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._cheatWitnessInfoMap, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo, rhs: Protocol_NodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._beginSyncNum != rhs_storage._beginSyncNum {return false}
        if _storage._block != rhs_storage._block {return false}
        if _storage._solidityBlock != rhs_storage._solidityBlock {return false}
        if _storage._currentConnectCount != rhs_storage._currentConnectCount {return false}
        if _storage._activeConnectCount != rhs_storage._activeConnectCount {return false}
        if _storage._passiveConnectCount != rhs_storage._passiveConnectCount {return false}
        if _storage._totalFlow != rhs_storage._totalFlow {return false}
        if _storage._peerInfoList != rhs_storage._peerInfoList {return false}
        if _storage._configNodeInfo != rhs_storage._configNodeInfo {return false}
        if _storage._machineInfo != rhs_storage._machineInfo {return false}
        if _storage._cheatWitnessInfoMap != rhs_storage._cheatWitnessInfoMap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.PeerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".PeerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncBlock"),
    2: .same(proto: "remainNum"),
    3: .same(proto: "lastBlockUpdateTime"),
    4: .same(proto: "syncFlag"),
    5: .same(proto: "headBlockTimeWeBothHave"),
    6: .same(proto: "needSyncFromPeer"),
    7: .same(proto: "needSyncFromUs"),
    8: .same(proto: "host"),
    9: .same(proto: "port"),
    10: .same(proto: "nodeId"),
    11: .same(proto: "connectTime"),
    12: .same(proto: "avgLatency"),
    13: .same(proto: "syncToFetchSize"),
    14: .same(proto: "syncToFetchSizePeekNum"),
    15: .same(proto: "syncBlockRequestedSize"),
    16: .same(proto: "unFetchSynNum"),
    17: .same(proto: "blockInPorcSize"),
    18: .same(proto: "headBlockWeBothHave"),
    19: .same(proto: "isActive"),
    20: .same(proto: "score"),
    21: .same(proto: "nodeCount"),
    22: .same(proto: "inFlow"),
    23: .same(proto: "disconnectTimes"),
    24: .same(proto: "localDisconnectReason"),
    25: .same(proto: "remoteDisconnectReason"),
  ]

  fileprivate class _StorageClass {
    var _lastSyncBlock: String = String()
    var _remainNum: Int64 = 0
    var _lastBlockUpdateTime: Int64 = 0
    var _syncFlag: Bool = false
    var _headBlockTimeWeBothHave: Int64 = 0
    var _needSyncFromPeer: Bool = false
    var _needSyncFromUs: Bool = false
    var _host: String = String()
    var _port: Int32 = 0
    var _nodeID: String = String()
    var _connectTime: Int64 = 0
    var _avgLatency: Double = 0
    var _syncToFetchSize: Int32 = 0
    var _syncToFetchSizePeekNum: Int64 = 0
    var _syncBlockRequestedSize: Int32 = 0
    var _unFetchSynNum: Int64 = 0
    var _blockInPorcSize: Int32 = 0
    var _headBlockWeBothHave: String = String()
    var _isActive: Bool = false
    var _score: Int32 = 0
    var _nodeCount: Int32 = 0
    var _inFlow: Int64 = 0
    var _disconnectTimes: Int32 = 0
    var _localDisconnectReason: String = String()
    var _remoteDisconnectReason: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lastSyncBlock = source._lastSyncBlock
      _remainNum = source._remainNum
      _lastBlockUpdateTime = source._lastBlockUpdateTime
      _syncFlag = source._syncFlag
      _headBlockTimeWeBothHave = source._headBlockTimeWeBothHave
      _needSyncFromPeer = source._needSyncFromPeer
      _needSyncFromUs = source._needSyncFromUs
      _host = source._host
      _port = source._port
      _nodeID = source._nodeID
      _connectTime = source._connectTime
      _avgLatency = source._avgLatency
      _syncToFetchSize = source._syncToFetchSize
      _syncToFetchSizePeekNum = source._syncToFetchSizePeekNum
      _syncBlockRequestedSize = source._syncBlockRequestedSize
      _unFetchSynNum = source._unFetchSynNum
      _blockInPorcSize = source._blockInPorcSize
      _headBlockWeBothHave = source._headBlockWeBothHave
      _isActive = source._isActive
      _score = source._score
      _nodeCount = source._nodeCount
      _inFlow = source._inFlow
      _disconnectTimes = source._disconnectTimes
      _localDisconnectReason = source._localDisconnectReason
      _remoteDisconnectReason = source._remoteDisconnectReason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._lastSyncBlock) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._remainNum) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._lastBlockUpdateTime) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._syncFlag) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._headBlockTimeWeBothHave) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._needSyncFromPeer) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._needSyncFromUs) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._host) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._port) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._nodeID) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._connectTime) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._avgLatency) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._syncToFetchSize) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._syncToFetchSizePeekNum) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._syncBlockRequestedSize) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._unFetchSynNum) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._blockInPorcSize) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._headBlockWeBothHave) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._isActive) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._score) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._nodeCount) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._inFlow) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._disconnectTimes) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._localDisconnectReason) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._remoteDisconnectReason) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._lastSyncBlock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastSyncBlock, fieldNumber: 1)
      }
      if _storage._remainNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._remainNum, fieldNumber: 2)
      }
      if _storage._lastBlockUpdateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastBlockUpdateTime, fieldNumber: 3)
      }
      if _storage._syncFlag != false {
        try visitor.visitSingularBoolField(value: _storage._syncFlag, fieldNumber: 4)
      }
      if _storage._headBlockTimeWeBothHave != 0 {
        try visitor.visitSingularInt64Field(value: _storage._headBlockTimeWeBothHave, fieldNumber: 5)
      }
      if _storage._needSyncFromPeer != false {
        try visitor.visitSingularBoolField(value: _storage._needSyncFromPeer, fieldNumber: 6)
      }
      if _storage._needSyncFromUs != false {
        try visitor.visitSingularBoolField(value: _storage._needSyncFromUs, fieldNumber: 7)
      }
      if !_storage._host.isEmpty {
        try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 8)
      }
      if _storage._port != 0 {
        try visitor.visitSingularInt32Field(value: _storage._port, fieldNumber: 9)
      }
      if !_storage._nodeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodeID, fieldNumber: 10)
      }
      if _storage._connectTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._connectTime, fieldNumber: 11)
      }
      if _storage._avgLatency != 0 {
        try visitor.visitSingularDoubleField(value: _storage._avgLatency, fieldNumber: 12)
      }
      if _storage._syncToFetchSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._syncToFetchSize, fieldNumber: 13)
      }
      if _storage._syncToFetchSizePeekNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._syncToFetchSizePeekNum, fieldNumber: 14)
      }
      if _storage._syncBlockRequestedSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._syncBlockRequestedSize, fieldNumber: 15)
      }
      if _storage._unFetchSynNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unFetchSynNum, fieldNumber: 16)
      }
      if _storage._blockInPorcSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blockInPorcSize, fieldNumber: 17)
      }
      if !_storage._headBlockWeBothHave.isEmpty {
        try visitor.visitSingularStringField(value: _storage._headBlockWeBothHave, fieldNumber: 18)
      }
      if _storage._isActive != false {
        try visitor.visitSingularBoolField(value: _storage._isActive, fieldNumber: 19)
      }
      if _storage._score != 0 {
        try visitor.visitSingularInt32Field(value: _storage._score, fieldNumber: 20)
      }
      if _storage._nodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nodeCount, fieldNumber: 21)
      }
      if _storage._inFlow != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inFlow, fieldNumber: 22)
      }
      if _storage._disconnectTimes != 0 {
        try visitor.visitSingularInt32Field(value: _storage._disconnectTimes, fieldNumber: 23)
      }
      if !_storage._localDisconnectReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._localDisconnectReason, fieldNumber: 24)
      }
      if !_storage._remoteDisconnectReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remoteDisconnectReason, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.PeerInfo, rhs: Protocol_NodeInfo.PeerInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lastSyncBlock != rhs_storage._lastSyncBlock {return false}
        if _storage._remainNum != rhs_storage._remainNum {return false}
        if _storage._lastBlockUpdateTime != rhs_storage._lastBlockUpdateTime {return false}
        if _storage._syncFlag != rhs_storage._syncFlag {return false}
        if _storage._headBlockTimeWeBothHave != rhs_storage._headBlockTimeWeBothHave {return false}
        if _storage._needSyncFromPeer != rhs_storage._needSyncFromPeer {return false}
        if _storage._needSyncFromUs != rhs_storage._needSyncFromUs {return false}
        if _storage._host != rhs_storage._host {return false}
        if _storage._port != rhs_storage._port {return false}
        if _storage._nodeID != rhs_storage._nodeID {return false}
        if _storage._connectTime != rhs_storage._connectTime {return false}
        if _storage._avgLatency != rhs_storage._avgLatency {return false}
        if _storage._syncToFetchSize != rhs_storage._syncToFetchSize {return false}
        if _storage._syncToFetchSizePeekNum != rhs_storage._syncToFetchSizePeekNum {return false}
        if _storage._syncBlockRequestedSize != rhs_storage._syncBlockRequestedSize {return false}
        if _storage._unFetchSynNum != rhs_storage._unFetchSynNum {return false}
        if _storage._blockInPorcSize != rhs_storage._blockInPorcSize {return false}
        if _storage._headBlockWeBothHave != rhs_storage._headBlockWeBothHave {return false}
        if _storage._isActive != rhs_storage._isActive {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._nodeCount != rhs_storage._nodeCount {return false}
        if _storage._inFlow != rhs_storage._inFlow {return false}
        if _storage._disconnectTimes != rhs_storage._disconnectTimes {return false}
        if _storage._localDisconnectReason != rhs_storage._localDisconnectReason {return false}
        if _storage._remoteDisconnectReason != rhs_storage._remoteDisconnectReason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.ConfigNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".ConfigNodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codeVersion"),
    2: .same(proto: "p2pVersion"),
    3: .same(proto: "listenPort"),
    4: .same(proto: "discoverEnable"),
    5: .same(proto: "activeNodeSize"),
    6: .same(proto: "passiveNodeSize"),
    7: .same(proto: "sendNodeSize"),
    8: .same(proto: "maxConnectCount"),
    9: .same(proto: "sameIpMaxConnectCount"),
    10: .same(proto: "backupListenPort"),
    11: .same(proto: "backupMemberSize"),
    12: .same(proto: "backupPriority"),
    13: .same(proto: "dbVersion"),
    14: .same(proto: "minParticipationRate"),
    15: .same(proto: "supportConstant"),
    16: .same(proto: "minTimeRatio"),
    17: .same(proto: "maxTimeRatio"),
    18: .same(proto: "allowCreationOfContracts"),
    19: .same(proto: "allowAdaptiveEnergy"),
  ]

  fileprivate class _StorageClass {
    var _codeVersion: String = String()
    var _p2PVersion: String = String()
    var _listenPort: Int32 = 0
    var _discoverEnable: Bool = false
    var _activeNodeSize: Int32 = 0
    var _passiveNodeSize: Int32 = 0
    var _sendNodeSize: Int32 = 0
    var _maxConnectCount: Int32 = 0
    var _sameIpMaxConnectCount: Int32 = 0
    var _backupListenPort: Int32 = 0
    var _backupMemberSize: Int32 = 0
    var _backupPriority: Int32 = 0
    var _dbVersion: Int32 = 0
    var _minParticipationRate: Int32 = 0
    var _supportConstant: Bool = false
    var _minTimeRatio: Double = 0
    var _maxTimeRatio: Double = 0
    var _allowCreationOfContracts: Int64 = 0
    var _allowAdaptiveEnergy: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _codeVersion = source._codeVersion
      _p2PVersion = source._p2PVersion
      _listenPort = source._listenPort
      _discoverEnable = source._discoverEnable
      _activeNodeSize = source._activeNodeSize
      _passiveNodeSize = source._passiveNodeSize
      _sendNodeSize = source._sendNodeSize
      _maxConnectCount = source._maxConnectCount
      _sameIpMaxConnectCount = source._sameIpMaxConnectCount
      _backupListenPort = source._backupListenPort
      _backupMemberSize = source._backupMemberSize
      _backupPriority = source._backupPriority
      _dbVersion = source._dbVersion
      _minParticipationRate = source._minParticipationRate
      _supportConstant = source._supportConstant
      _minTimeRatio = source._minTimeRatio
      _maxTimeRatio = source._maxTimeRatio
      _allowCreationOfContracts = source._allowCreationOfContracts
      _allowAdaptiveEnergy = source._allowAdaptiveEnergy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._codeVersion) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._p2PVersion) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._listenPort) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._discoverEnable) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._activeNodeSize) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._passiveNodeSize) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._sendNodeSize) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._maxConnectCount) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._sameIpMaxConnectCount) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._backupListenPort) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._backupMemberSize) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._backupPriority) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._dbVersion) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._minParticipationRate) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._supportConstant) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._minTimeRatio) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._maxTimeRatio) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._allowCreationOfContracts) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._allowAdaptiveEnergy) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._codeVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._codeVersion, fieldNumber: 1)
      }
      if !_storage._p2PVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._p2PVersion, fieldNumber: 2)
      }
      if _storage._listenPort != 0 {
        try visitor.visitSingularInt32Field(value: _storage._listenPort, fieldNumber: 3)
      }
      if _storage._discoverEnable != false {
        try visitor.visitSingularBoolField(value: _storage._discoverEnable, fieldNumber: 4)
      }
      if _storage._activeNodeSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._activeNodeSize, fieldNumber: 5)
      }
      if _storage._passiveNodeSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._passiveNodeSize, fieldNumber: 6)
      }
      if _storage._sendNodeSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sendNodeSize, fieldNumber: 7)
      }
      if _storage._maxConnectCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxConnectCount, fieldNumber: 8)
      }
      if _storage._sameIpMaxConnectCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sameIpMaxConnectCount, fieldNumber: 9)
      }
      if _storage._backupListenPort != 0 {
        try visitor.visitSingularInt32Field(value: _storage._backupListenPort, fieldNumber: 10)
      }
      if _storage._backupMemberSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._backupMemberSize, fieldNumber: 11)
      }
      if _storage._backupPriority != 0 {
        try visitor.visitSingularInt32Field(value: _storage._backupPriority, fieldNumber: 12)
      }
      if _storage._dbVersion != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dbVersion, fieldNumber: 13)
      }
      if _storage._minParticipationRate != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minParticipationRate, fieldNumber: 14)
      }
      if _storage._supportConstant != false {
        try visitor.visitSingularBoolField(value: _storage._supportConstant, fieldNumber: 15)
      }
      if _storage._minTimeRatio != 0 {
        try visitor.visitSingularDoubleField(value: _storage._minTimeRatio, fieldNumber: 16)
      }
      if _storage._maxTimeRatio != 0 {
        try visitor.visitSingularDoubleField(value: _storage._maxTimeRatio, fieldNumber: 17)
      }
      if _storage._allowCreationOfContracts != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allowCreationOfContracts, fieldNumber: 18)
      }
      if _storage._allowAdaptiveEnergy != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allowAdaptiveEnergy, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.ConfigNodeInfo, rhs: Protocol_NodeInfo.ConfigNodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._codeVersion != rhs_storage._codeVersion {return false}
        if _storage._p2PVersion != rhs_storage._p2PVersion {return false}
        if _storage._listenPort != rhs_storage._listenPort {return false}
        if _storage._discoverEnable != rhs_storage._discoverEnable {return false}
        if _storage._activeNodeSize != rhs_storage._activeNodeSize {return false}
        if _storage._passiveNodeSize != rhs_storage._passiveNodeSize {return false}
        if _storage._sendNodeSize != rhs_storage._sendNodeSize {return false}
        if _storage._maxConnectCount != rhs_storage._maxConnectCount {return false}
        if _storage._sameIpMaxConnectCount != rhs_storage._sameIpMaxConnectCount {return false}
        if _storage._backupListenPort != rhs_storage._backupListenPort {return false}
        if _storage._backupMemberSize != rhs_storage._backupMemberSize {return false}
        if _storage._backupPriority != rhs_storage._backupPriority {return false}
        if _storage._dbVersion != rhs_storage._dbVersion {return false}
        if _storage._minParticipationRate != rhs_storage._minParticipationRate {return false}
        if _storage._supportConstant != rhs_storage._supportConstant {return false}
        if _storage._minTimeRatio != rhs_storage._minTimeRatio {return false}
        if _storage._maxTimeRatio != rhs_storage._maxTimeRatio {return false}
        if _storage._allowCreationOfContracts != rhs_storage._allowCreationOfContracts {return false}
        if _storage._allowAdaptiveEnergy != rhs_storage._allowAdaptiveEnergy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.MachineInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".MachineInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threadCount"),
    2: .same(proto: "deadLockThreadCount"),
    3: .same(proto: "cpuCount"),
    4: .same(proto: "totalMemory"),
    5: .same(proto: "freeMemory"),
    6: .same(proto: "cpuRate"),
    7: .same(proto: "javaVersion"),
    8: .same(proto: "osName"),
    9: .same(proto: "jvmTotalMemory"),
    10: .same(proto: "jvmFreeMemory"),
    11: .same(proto: "processCpuRate"),
    12: .same(proto: "memoryDescInfoList"),
    13: .same(proto: "deadLockThreadInfoList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.threadCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.deadLockThreadCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.cpuCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalMemory) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.freeMemory) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.cpuRate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.javaVersion) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.osName) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.jvmTotalMemory) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.jvmFreeMemory) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self.processCpuRate) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.memoryDescInfoList) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.deadLockThreadInfoList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threadCount != 0 {
      try visitor.visitSingularInt32Field(value: self.threadCount, fieldNumber: 1)
    }
    if self.deadLockThreadCount != 0 {
      try visitor.visitSingularInt32Field(value: self.deadLockThreadCount, fieldNumber: 2)
    }
    if self.cpuCount != 0 {
      try visitor.visitSingularInt32Field(value: self.cpuCount, fieldNumber: 3)
    }
    if self.totalMemory != 0 {
      try visitor.visitSingularInt64Field(value: self.totalMemory, fieldNumber: 4)
    }
    if self.freeMemory != 0 {
      try visitor.visitSingularInt64Field(value: self.freeMemory, fieldNumber: 5)
    }
    if self.cpuRate != 0 {
      try visitor.visitSingularDoubleField(value: self.cpuRate, fieldNumber: 6)
    }
    if !self.javaVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.javaVersion, fieldNumber: 7)
    }
    if !self.osName.isEmpty {
      try visitor.visitSingularStringField(value: self.osName, fieldNumber: 8)
    }
    if self.jvmTotalMemory != 0 {
      try visitor.visitSingularInt64Field(value: self.jvmTotalMemory, fieldNumber: 9)
    }
    if self.jvmFreeMemory != 0 {
      try visitor.visitSingularInt64Field(value: self.jvmFreeMemory, fieldNumber: 10)
    }
    if self.processCpuRate != 0 {
      try visitor.visitSingularDoubleField(value: self.processCpuRate, fieldNumber: 11)
    }
    if !self.memoryDescInfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.memoryDescInfoList, fieldNumber: 12)
    }
    if !self.deadLockThreadInfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deadLockThreadInfoList, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.MachineInfo, rhs: Protocol_NodeInfo.MachineInfo) -> Bool {
    if lhs.threadCount != rhs.threadCount {return false}
    if lhs.deadLockThreadCount != rhs.deadLockThreadCount {return false}
    if lhs.cpuCount != rhs.cpuCount {return false}
    if lhs.totalMemory != rhs.totalMemory {return false}
    if lhs.freeMemory != rhs.freeMemory {return false}
    if lhs.cpuRate != rhs.cpuRate {return false}
    if lhs.javaVersion != rhs.javaVersion {return false}
    if lhs.osName != rhs.osName {return false}
    if lhs.jvmTotalMemory != rhs.jvmTotalMemory {return false}
    if lhs.jvmFreeMemory != rhs.jvmFreeMemory {return false}
    if lhs.processCpuRate != rhs.processCpuRate {return false}
    if lhs.memoryDescInfoList != rhs.memoryDescInfoList {return false}
    if lhs.deadLockThreadInfoList != rhs.deadLockThreadInfoList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.MachineInfo.MemoryDescInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.MachineInfo.protoMessageName + ".MemoryDescInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "initSize"),
    3: .same(proto: "useSize"),
    4: .same(proto: "maxSize"),
    5: .same(proto: "useRate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.initSize) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.useSize) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.maxSize) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.useRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.initSize != 0 {
      try visitor.visitSingularInt64Field(value: self.initSize, fieldNumber: 2)
    }
    if self.useSize != 0 {
      try visitor.visitSingularInt64Field(value: self.useSize, fieldNumber: 3)
    }
    if self.maxSize != 0 {
      try visitor.visitSingularInt64Field(value: self.maxSize, fieldNumber: 4)
    }
    if self.useRate != 0 {
      try visitor.visitSingularDoubleField(value: self.useRate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.MachineInfo.MemoryDescInfo, rhs: Protocol_NodeInfo.MachineInfo.MemoryDescInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.initSize != rhs.initSize {return false}
    if lhs.useSize != rhs.useSize {return false}
    if lhs.maxSize != rhs.maxSize {return false}
    if lhs.useRate != rhs.useRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.MachineInfo.protoMessageName + ".DeadLockThreadInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "lockName"),
    3: .same(proto: "lockOwner"),
    4: .same(proto: "state"),
    5: .same(proto: "blockTime"),
    6: .same(proto: "waitTime"),
    7: .same(proto: "stackTrace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lockName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lockOwner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.blockTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.waitTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.stackTrace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.lockName.isEmpty {
      try visitor.visitSingularStringField(value: self.lockName, fieldNumber: 2)
    }
    if !self.lockOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.lockOwner, fieldNumber: 3)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 4)
    }
    if self.blockTime != 0 {
      try visitor.visitSingularInt64Field(value: self.blockTime, fieldNumber: 5)
    }
    if self.waitTime != 0 {
      try visitor.visitSingularInt64Field(value: self.waitTime, fieldNumber: 6)
    }
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo, rhs: Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.lockName != rhs.lockName {return false}
    if lhs.lockOwner != rhs.lockOwner {return false}
    if lhs.state != rhs.state {return false}
    if lhs.blockTime != rhs.blockTime {return false}
    if lhs.waitTime != rhs.waitTime {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricsInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
    2: .same(proto: "node"),
    3: .same(proto: "blockchain"),
    4: .same(proto: "net"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.interval) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockchain) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._net) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.interval != 0 {
      try visitor.visitSingularInt64Field(value: self.interval, fieldNumber: 1)
    }
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blockchain {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._net {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo, rhs: Protocol_MetricsInfo) -> Bool {
    if lhs.interval != rhs.interval {return false}
    if lhs._node != rhs._node {return false}
    if lhs._blockchain != rhs._blockchain {return false}
    if lhs._net != rhs._net {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.protoMessageName + ".NodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "nodeType"),
    3: .same(proto: "version"),
    4: .same(proto: "backupStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.nodeType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.backupStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    if self.nodeType != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeType, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if self.backupStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.backupStatus, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.NodeInfo, rhs: Protocol_MetricsInfo.NodeInfo) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.nodeType != rhs.nodeType {return false}
    if lhs.version != rhs.version {return false}
    if lhs.backupStatus != rhs.backupStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.BlockChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.protoMessageName + ".BlockChainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "headBlockNum"),
    2: .same(proto: "headBlockTimestamp"),
    3: .same(proto: "headBlockHash"),
    4: .same(proto: "forkCount"),
    5: .same(proto: "failForkCount"),
    6: .same(proto: "blockProcessTime"),
    7: .same(proto: "tps"),
    8: .same(proto: "transactionCacheSize"),
    9: .same(proto: "missedTransaction"),
    10: .same(proto: "witnesses"),
    11: .same(proto: "failProcessBlockNum"),
    12: .same(proto: "failProcessBlockReason"),
    13: .same(proto: "dupWitness"),
  ]

  fileprivate class _StorageClass {
    var _headBlockNum: Int64 = 0
    var _headBlockTimestamp: Int64 = 0
    var _headBlockHash: String = String()
    var _forkCount: Int32 = 0
    var _failForkCount: Int32 = 0
    var _blockProcessTime: Protocol_MetricsInfo.RateInfo? = nil
    var _tps: Protocol_MetricsInfo.RateInfo? = nil
    var _transactionCacheSize: Int32 = 0
    var _missedTransaction: Protocol_MetricsInfo.RateInfo? = nil
    var _witnesses: [Protocol_MetricsInfo.BlockChainInfo.Witness] = []
    var _failProcessBlockNum: Int64 = 0
    var _failProcessBlockReason: String = String()
    var _dupWitness: [Protocol_MetricsInfo.BlockChainInfo.DupWitness] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _headBlockNum = source._headBlockNum
      _headBlockTimestamp = source._headBlockTimestamp
      _headBlockHash = source._headBlockHash
      _forkCount = source._forkCount
      _failForkCount = source._failForkCount
      _blockProcessTime = source._blockProcessTime
      _tps = source._tps
      _transactionCacheSize = source._transactionCacheSize
      _missedTransaction = source._missedTransaction
      _witnesses = source._witnesses
      _failProcessBlockNum = source._failProcessBlockNum
      _failProcessBlockReason = source._failProcessBlockReason
      _dupWitness = source._dupWitness
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._headBlockNum) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._headBlockTimestamp) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._headBlockHash) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._forkCount) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._failForkCount) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._blockProcessTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tps) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._transactionCacheSize) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._missedTransaction) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._witnesses) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._failProcessBlockNum) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._failProcessBlockReason) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._dupWitness) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._headBlockNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._headBlockNum, fieldNumber: 1)
      }
      if _storage._headBlockTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._headBlockTimestamp, fieldNumber: 2)
      }
      if !_storage._headBlockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._headBlockHash, fieldNumber: 3)
      }
      if _storage._forkCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._forkCount, fieldNumber: 4)
      }
      if _storage._failForkCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._failForkCount, fieldNumber: 5)
      }
      try { if let v = _storage._blockProcessTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._transactionCacheSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._transactionCacheSize, fieldNumber: 8)
      }
      try { if let v = _storage._missedTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._witnesses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._witnesses, fieldNumber: 10)
      }
      if _storage._failProcessBlockNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._failProcessBlockNum, fieldNumber: 11)
      }
      if !_storage._failProcessBlockReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._failProcessBlockReason, fieldNumber: 12)
      }
      if !_storage._dupWitness.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dupWitness, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.BlockChainInfo, rhs: Protocol_MetricsInfo.BlockChainInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._headBlockNum != rhs_storage._headBlockNum {return false}
        if _storage._headBlockTimestamp != rhs_storage._headBlockTimestamp {return false}
        if _storage._headBlockHash != rhs_storage._headBlockHash {return false}
        if _storage._forkCount != rhs_storage._forkCount {return false}
        if _storage._failForkCount != rhs_storage._failForkCount {return false}
        if _storage._blockProcessTime != rhs_storage._blockProcessTime {return false}
        if _storage._tps != rhs_storage._tps {return false}
        if _storage._transactionCacheSize != rhs_storage._transactionCacheSize {return false}
        if _storage._missedTransaction != rhs_storage._missedTransaction {return false}
        if _storage._witnesses != rhs_storage._witnesses {return false}
        if _storage._failProcessBlockNum != rhs_storage._failProcessBlockNum {return false}
        if _storage._failProcessBlockReason != rhs_storage._failProcessBlockReason {return false}
        if _storage._dupWitness != rhs_storage._dupWitness {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.BlockChainInfo.Witness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.BlockChainInfo.protoMessageName + ".Witness"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.BlockChainInfo.Witness, rhs: Protocol_MetricsInfo.BlockChainInfo.Witness) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.BlockChainInfo.DupWitness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.BlockChainInfo.protoMessageName + ".DupWitness"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "blockNum"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.blockNum) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.blockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.blockNum, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.BlockChainInfo.DupWitness, rhs: Protocol_MetricsInfo.BlockChainInfo.DupWitness) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.blockNum != rhs.blockNum {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.RateInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.protoMessageName + ".RateInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "meanRate"),
    3: .same(proto: "oneMinuteRate"),
    4: .same(proto: "fiveMinuteRate"),
    5: .same(proto: "fifteenMinuteRate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.meanRate) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.oneMinuteRate) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.fiveMinuteRate) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.fifteenMinuteRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if self.meanRate != 0 {
      try visitor.visitSingularDoubleField(value: self.meanRate, fieldNumber: 2)
    }
    if self.oneMinuteRate != 0 {
      try visitor.visitSingularDoubleField(value: self.oneMinuteRate, fieldNumber: 3)
    }
    if self.fiveMinuteRate != 0 {
      try visitor.visitSingularDoubleField(value: self.fiveMinuteRate, fieldNumber: 4)
    }
    if self.fifteenMinuteRate != 0 {
      try visitor.visitSingularDoubleField(value: self.fifteenMinuteRate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.RateInfo, rhs: Protocol_MetricsInfo.RateInfo) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.meanRate != rhs.meanRate {return false}
    if lhs.oneMinuteRate != rhs.oneMinuteRate {return false}
    if lhs.fiveMinuteRate != rhs.fiveMinuteRate {return false}
    if lhs.fifteenMinuteRate != rhs.fifteenMinuteRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.NetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.protoMessageName + ".NetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errorProtoCount"),
    2: .same(proto: "api"),
    3: .same(proto: "connectionCount"),
    4: .same(proto: "validConnectionCount"),
    5: .same(proto: "tcpInTraffic"),
    6: .same(proto: "tcpOutTraffic"),
    7: .same(proto: "disconnectionCount"),
    8: .same(proto: "disconnectionDetail"),
    9: .same(proto: "udpInTraffic"),
    10: .same(proto: "udpOutTraffic"),
    11: .same(proto: "latency"),
  ]

  fileprivate class _StorageClass {
    var _errorProtoCount: Int32 = 0
    var _api: Protocol_MetricsInfo.NetInfo.ApiInfo? = nil
    var _connectionCount: Int32 = 0
    var _validConnectionCount: Int32 = 0
    var _tcpInTraffic: Protocol_MetricsInfo.RateInfo? = nil
    var _tcpOutTraffic: Protocol_MetricsInfo.RateInfo? = nil
    var _disconnectionCount: Int32 = 0
    var _disconnectionDetail: [Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo] = []
    var _udpInTraffic: Protocol_MetricsInfo.RateInfo? = nil
    var _udpOutTraffic: Protocol_MetricsInfo.RateInfo? = nil
    var _latency: Protocol_MetricsInfo.NetInfo.LatencyInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _errorProtoCount = source._errorProtoCount
      _api = source._api
      _connectionCount = source._connectionCount
      _validConnectionCount = source._validConnectionCount
      _tcpInTraffic = source._tcpInTraffic
      _tcpOutTraffic = source._tcpOutTraffic
      _disconnectionCount = source._disconnectionCount
      _disconnectionDetail = source._disconnectionDetail
      _udpInTraffic = source._udpInTraffic
      _udpOutTraffic = source._udpOutTraffic
      _latency = source._latency
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._errorProtoCount) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._api) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._connectionCount) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._validConnectionCount) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._tcpInTraffic) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._tcpOutTraffic) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._disconnectionCount) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._disconnectionDetail) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._udpInTraffic) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._udpOutTraffic) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._latency) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._errorProtoCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._errorProtoCount, fieldNumber: 1)
      }
      try { if let v = _storage._api {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._connectionCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._connectionCount, fieldNumber: 3)
      }
      if _storage._validConnectionCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._validConnectionCount, fieldNumber: 4)
      }
      try { if let v = _storage._tcpInTraffic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._tcpOutTraffic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._disconnectionCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._disconnectionCount, fieldNumber: 7)
      }
      if !_storage._disconnectionDetail.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._disconnectionDetail, fieldNumber: 8)
      }
      try { if let v = _storage._udpInTraffic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._udpOutTraffic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._latency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.NetInfo, rhs: Protocol_MetricsInfo.NetInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._errorProtoCount != rhs_storage._errorProtoCount {return false}
        if _storage._api != rhs_storage._api {return false}
        if _storage._connectionCount != rhs_storage._connectionCount {return false}
        if _storage._validConnectionCount != rhs_storage._validConnectionCount {return false}
        if _storage._tcpInTraffic != rhs_storage._tcpInTraffic {return false}
        if _storage._tcpOutTraffic != rhs_storage._tcpOutTraffic {return false}
        if _storage._disconnectionCount != rhs_storage._disconnectionCount {return false}
        if _storage._disconnectionDetail != rhs_storage._disconnectionDetail {return false}
        if _storage._udpInTraffic != rhs_storage._udpInTraffic {return false}
        if _storage._udpOutTraffic != rhs_storage._udpOutTraffic {return false}
        if _storage._latency != rhs_storage._latency {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.NetInfo.ApiInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.protoMessageName + ".ApiInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "qps"),
    2: .same(proto: "failQps"),
    3: .same(proto: "outTraffic"),
    4: .same(proto: "detail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._qps) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failQps) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._outTraffic) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._qps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._failQps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._outTraffic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.detail.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.detail, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.NetInfo.ApiInfo, rhs: Protocol_MetricsInfo.NetInfo.ApiInfo) -> Bool {
    if lhs._qps != rhs._qps {return false}
    if lhs._failQps != rhs._failQps {return false}
    if lhs._outTraffic != rhs._outTraffic {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.ApiInfo.protoMessageName + ".ApiDetailInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "qps"),
    3: .same(proto: "failQps"),
    4: .same(proto: "outTraffic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._qps) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failQps) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._outTraffic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._qps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._failQps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outTraffic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo, rhs: Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._qps != rhs._qps {return false}
    if lhs._failQps != rhs._failQps {return false}
    if lhs._outTraffic != rhs._outTraffic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.protoMessageName + ".DisconnectionDetailInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo, rhs: Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.NetInfo.LatencyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.protoMessageName + ".LatencyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "top99"),
    2: .same(proto: "top95"),
    3: .same(proto: "top75"),
    4: .same(proto: "totalCount"),
    5: .same(proto: "delay1S"),
    6: .same(proto: "delay2S"),
    7: .same(proto: "delay3S"),
    8: .same(proto: "detail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.top99) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.top95) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.top75) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.delay1S) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.delay2S) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.delay3S) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.top99 != 0 {
      try visitor.visitSingularInt32Field(value: self.top99, fieldNumber: 1)
    }
    if self.top95 != 0 {
      try visitor.visitSingularInt32Field(value: self.top95, fieldNumber: 2)
    }
    if self.top75 != 0 {
      try visitor.visitSingularInt32Field(value: self.top75, fieldNumber: 3)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 4)
    }
    if self.delay1S != 0 {
      try visitor.visitSingularInt32Field(value: self.delay1S, fieldNumber: 5)
    }
    if self.delay2S != 0 {
      try visitor.visitSingularInt32Field(value: self.delay2S, fieldNumber: 6)
    }
    if self.delay3S != 0 {
      try visitor.visitSingularInt32Field(value: self.delay3S, fieldNumber: 7)
    }
    if !self.detail.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.detail, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.NetInfo.LatencyInfo, rhs: Protocol_MetricsInfo.NetInfo.LatencyInfo) -> Bool {
    if lhs.top99 != rhs.top99 {return false}
    if lhs.top95 != rhs.top95 {return false}
    if lhs.top75 != rhs.top75 {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.delay1S != rhs.delay1S {return false}
    if lhs.delay2S != rhs.delay2S {return false}
    if lhs.delay3S != rhs.delay3S {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.LatencyInfo.protoMessageName + ".LatencyDetailInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "witness"),
    2: .same(proto: "top99"),
    3: .same(proto: "top95"),
    4: .same(proto: "top75"),
    5: .same(proto: "count"),
    6: .same(proto: "delay1S"),
    7: .same(proto: "delay2S"),
    8: .same(proto: "delay3S"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.witness) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.top99) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.top95) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.top75) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.delay1S) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.delay2S) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.delay3S) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.witness.isEmpty {
      try visitor.visitSingularStringField(value: self.witness, fieldNumber: 1)
    }
    if self.top99 != 0 {
      try visitor.visitSingularInt32Field(value: self.top99, fieldNumber: 2)
    }
    if self.top95 != 0 {
      try visitor.visitSingularInt32Field(value: self.top95, fieldNumber: 3)
    }
    if self.top75 != 0 {
      try visitor.visitSingularInt32Field(value: self.top75, fieldNumber: 4)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 5)
    }
    if self.delay1S != 0 {
      try visitor.visitSingularInt32Field(value: self.delay1S, fieldNumber: 6)
    }
    if self.delay2S != 0 {
      try visitor.visitSingularInt32Field(value: self.delay2S, fieldNumber: 7)
    }
    if self.delay3S != 0 {
      try visitor.visitSingularInt32Field(value: self.delay3S, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo, rhs: Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo) -> Bool {
    if lhs.witness != rhs.witness {return false}
    if lhs.top99 != rhs.top99 {return false}
    if lhs.top95 != rhs.top95 {return false}
    if lhs.top75 != rhs.top75 {return false}
    if lhs.count != rhs.count {return false}
    if lhs.delay1S != rhs.delay1S {return false}
    if lhs.delay2S != rhs.delay2S {return false}
    if lhs.delay3S != rhs.delay3S {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PBFTMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PBFTMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawData) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PBFTMessage, rhs: Protocol_PBFTMessage) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PBFTMessage.MsgType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIEW_CHANGE"),
    1: .same(proto: "REQUEST"),
    2: .same(proto: "PREPREPARE"),
    3: .same(proto: "PREPARE"),
    4: .same(proto: "COMMIT"),
  ]
}

extension Protocol_PBFTMessage.DataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLOCK"),
    1: .same(proto: "SRL"),
  ]
}

extension Protocol_PBFTMessage.Raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_PBFTMessage.protoMessageName + ".Raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_type"),
    2: .standard(proto: "data_type"),
    3: .standard(proto: "view_n"),
    4: .same(proto: "epoch"),
    5: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.msgType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dataType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.viewN) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.epoch) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgType != .viewChange {
      try visitor.visitSingularEnumField(value: self.msgType, fieldNumber: 1)
    }
    if self.dataType != .block {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 2)
    }
    if self.viewN != 0 {
      try visitor.visitSingularInt64Field(value: self.viewN, fieldNumber: 3)
    }
    if self.epoch != 0 {
      try visitor.visitSingularInt64Field(value: self.epoch, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PBFTMessage.Raw, rhs: Protocol_PBFTMessage.Raw) -> Bool {
    if lhs.msgType != rhs.msgType {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs.viewN != rhs.viewN {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PBFTCommitResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PBFTCommitResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_PBFTCommitResult, rhs: Protocol_PBFTCommitResult) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SRL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SRL"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "srAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.srAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srAddress.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.srAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_SRL, rhs: Protocol_SRL) -> Bool {
    if lhs.srAddress != rhs.srAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
